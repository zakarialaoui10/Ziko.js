{
  "Addons_Chart_index_js_content": "\r\n",
  "Addons_Chart_index_js_stats_length": 2,
  "Addons_Chart_index_js_stats_size": 0.001953125,
  "Addons_Chart_index_js_stats_lines": 2,
  "Addons_Chart_index_js_metadata_permissions": 33206,
  "Addons_Driver_index_js_content": "\r\n",
  "Addons_Driver_index_js_stats_length": 2,
  "Addons_Driver_index_js_stats_size": 0.001953125,
  "Addons_Driver_index_js_stats_lines": 2,
  "Addons_Driver_index_js_metadata_permissions": 33206,
  "Addons_Highlight_index_js_content": "\r\n",
  "Addons_Highlight_index_js_stats_length": 2,
  "Addons_Highlight_index_js_stats_size": 0.001953125,
  "Addons_Highlight_index_js_stats_lines": 2,
  "Addons_Highlight_index_js_metadata_permissions": 33206,
  "Addons_JsPDF_index_js_content": "\r\n",
  "Addons_JsPDF_index_js_stats_length": 2,
  "Addons_JsPDF_index_js_stats_size": 0.001953125,
  "Addons_JsPDF_index_js_stats_lines": 2,
  "Addons_JsPDF_index_js_metadata_permissions": 33206,
  "Addons_Leaflet_index_js_content": "\r\n",
  "Addons_Leaflet_index_js_stats_length": 2,
  "Addons_Leaflet_index_js_stats_size": 0.001953125,
  "Addons_Leaflet_index_js_stats_lines": 2,
  "Addons_Leaflet_index_js_metadata_permissions": 33206,
  "Addons_Marked_index_js_content": "\r\n",
  "Addons_Marked_index_js_stats_length": 2,
  "Addons_Marked_index_js_stats_size": 0.001953125,
  "Addons_Marked_index_js_stats_lines": 2,
  "Addons_Marked_index_js_metadata_permissions": 33206,
  "Addons_P5_index_js_content": "\r\n",
  "Addons_P5_index_js_stats_length": 2,
  "Addons_P5_index_js_stats_size": 0.001953125,
  "Addons_P5_index_js_stats_lines": 2,
  "Addons_P5_index_js_metadata_permissions": 33206,
  "Addons_Reveal_index_js_content": "\r\n",
  "Addons_Reveal_index_js_stats_length": 2,
  "Addons_Reveal_index_js_stats_size": 0.001953125,
  "Addons_Reveal_index_js_stats_lines": 2,
  "Addons_Reveal_index_js_metadata_permissions": 33206,
  "Addons_Sheet_index_js_content": "\r\n",
  "Addons_Sheet_index_js_stats_length": 2,
  "Addons_Sheet_index_js_stats_size": 0.001953125,
  "Addons_Sheet_index_js_stats_lines": 2,
  "Addons_Sheet_index_js_metadata_permissions": 33206,
  "Addons_Three_index_js_content": "\r\n",
  "Addons_Three_index_js_stats_length": 2,
  "Addons_Three_index_js_stats_size": 0.001953125,
  "Addons_Three_index_js_stats_lines": 2,
  "Addons_Three_index_js_metadata_permissions": 33206,
  "Data_Converter_csv_js_content": "",
  "Data_Converter_csv_js_stats_length": 0,
  "Data_Converter_csv_js_stats_size": 0,
  "Data_Converter_csv_js_stats_lines": 1,
  "Data_Converter_csv_js_metadata_permissions": 33206,
  "Data_Converter_svg_js_content": "",
  "Data_Converter_svg_js_stats_length": 0,
  "Data_Converter_svg_js_stats_size": 0,
  "Data_Converter_svg_js_stats_lines": 1,
  "Data_Converter_svg_js_metadata_permissions": 33206,
  "Data_Parser_markdown_js_content": "",
  "Data_Parser_markdown_js_stats_length": 0,
  "Data_Parser_markdown_js_stats_size": 0,
  "Data_Parser_markdown_js_stats_lines": 1,
  "Data_Parser_markdown_js_metadata_permissions": 33206,
  "Data_Parser_xml_js_content": "function parseXML(xmlString) {\r\n    const parser = new DOMParser();\r\n    const xmlDoc = parser.parseFromString(xmlString, 'text/xml');\r\n    const rootNode = xmlDoc.documentElement;\r\n    const result = parseNode(rootNode);\r\n    return result;\r\n  }\r\n  \r\n  function parseNode(node) {\r\n    const obj = {\r\n      type: node.nodeName,\r\n      attributes: {},\r\n      children: []\r\n    };\r\n    for (let i = 0; i < node.attributes.length; i++) {\r\n      const attr = node.attributes[i];\r\n      obj.attributes[attr.name] = attr.value;\r\n    }\r\n    for (let i = 0; i < node.childNodes.length; i++) {\r\n      const child = node.childNodes[i];\r\n      if (child.nodeType === Node.ELEMENT_NODE) {\r\n        obj.children.push(parseNode(child));\r\n      } else if (child.nodeType === Node.TEXT_NODE) {\r\n        obj.text = child.textContent.trim();\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n  export default parseXML;\r\n\r\n  // function htmlParser(element) {\r\n  //   const obj = {\r\n  //     type: element.tagName,\r\n  //     attributes: {},\r\n  //     children: [],\r\n  //   };\r\n  //   for (let i = 0; i < element.attributes.length; i++) {\r\n  //     const attr = element.attributes[i];\r\n  //     obj.attributes[attr.name] = attr.value;\r\n  //   }\r\n  //   for (let i = 0; i < element.children.length; i++) {\r\n  //     const child = element.children[i];\r\n  //     obj.children.push(htmlParser(child));\r\n  //   }\r\n  //   return obj;\r\n  // }\r\n ",
  "Data_Parser_xml_js_stats_length": 1406,
  "Data_Parser_xml_js_stats_size": 1.373046875,
  "Data_Parser_xml_js_stats_lines": 47,
  "Data_Parser_xml_js_metadata_permissions": 33206,
  "Data_decorators_js_content": "",
  "Data_decorators_js_stats_length": 0,
  "Data_decorators_js_stats_size": 0,
  "Data_decorators_js_stats_lines": 1,
  "Data_decorators_js_metadata_permissions": 33206,
  "Data_index_js_content": "\r\n",
  "Data_index_js_stats_length": 2,
  "Data_index_js_stats_size": 0.001953125,
  "Data_index_js_stats_lines": 2,
  "Data_index_js_metadata_permissions": 33206,
  "Events_EventEmitter_js_content": "class EventEmitter {\r\n    constructor() {\r\n      this.events = {};\r\n      this.maxListeners = 10; // Default maximum number of listeners\r\n    }\r\n  \r\n    on(event, listener) {\r\n      if (!this.events[event]) {\r\n        this.events[event] = [];\r\n      }\r\n      this.events[event].push(listener);\r\n  \r\n      // Check if the number of listeners for the event exceeds the maximum\r\n      if (this.events[event].length > this.maxListeners) {\r\n        console.warn(`Warning: Possible memory leak. Event '${event}' has more than ${this.maxListeners} listeners.`);\r\n      }\r\n    }\r\n  \r\n    once(event, listener) {\r\n      const onceListener = (data) => {\r\n        this.off(event, onceListener); // Remove the listener after it's been called\r\n        listener(data);\r\n      };\r\n      this.on(event, onceListener);\r\n    }\r\n  \r\n    off(event, listener) {\r\n      const listeners = this.events[event];\r\n      if (listeners) {\r\n        const index = listeners.indexOf(listener);\r\n        if (index !== -1) {\r\n          listeners.splice(index, 1);\r\n        }\r\n      }\r\n    }\r\n  \r\n    emit(event, data) {\r\n      const listeners = this.events[event];\r\n      if (listeners) {\r\n        listeners.forEach(listener => {\r\n          listener(data);\r\n        });\r\n      }\r\n    }\r\n  \r\n    clear(event) {\r\n      if (event) {\r\n        delete this.events[event];\r\n      } else {\r\n        this.events = {};\r\n      }\r\n    }\r\n  \r\n    setMaxListener(event, max) {\r\n      this.maxListeners = max;\r\n    }\r\n  \r\n    removeAllListeners(event) {\r\n      if (event) {\r\n        this.events[event] = [];\r\n      } else {\r\n        this.events = {};\r\n      }\r\n    }\r\n  }\r\n\r\nexport default EventEmitter;",
  "Events_EventEmitter_js_stats_length": 1654,
  "Events_EventEmitter_js_stats_size": 1.615234375,
  "Events_EventEmitter_js_stats_lines": 67,
  "Events_EventEmitter_js_metadata_permissions": 33206,
  "Events_Garbage_js_content": "const Garbage={\r\n    Key:{\r\n        data:[],\r\n        dispose:function(){\r\n            this.data.map(n=>n?.event?.dispose())\r\n            return this;\r\n        },\r\n        destroy:function(){\r\n            this.dispose();\r\n            this.data.length=0;\r\n            return this;\r\n        }\r\n    },\r\n    Pointer:{\r\n        data:[],\r\n        dispose:function(){\r\n            this.data.map(n=>n?.event?.dispose())\r\n            return this;\r\n        },\r\n        destroy:function(){\r\n            this.dispose();\r\n            this.data.length=0;\r\n            return this;\r\n        }\r\n    },\r\n    Drag:{\r\n        data:[],\r\n        dispose:function(){\r\n            this.data.map(n=>n?.event?.dispose())\r\n            return this;\r\n        },\r\n        destroy:function(){\r\n            this.dispose();\r\n            this.data.length=0;\r\n            return this;\r\n        }\r\n    }\r\n}\r\nexport default Garbage",
  "Events_Garbage_js_stats_length": 895,
  "Events_Garbage_js_stats_size": 0.8740234375,
  "Events_Garbage_js_stats_lines": 39,
  "Events_Garbage_js_metadata_permissions": 33206,
  "Events_index_js_content": "\r\n",
  "Events_index_js_stats_length": 2,
  "Events_index_js_stats_size": 0.001953125,
  "Events_index_js_stats_lines": 2,
  "Events_index_js_metadata_permissions": 33206,
  "Events_Key_js_content": "//window.KeyGarbage=[]\r\nimport Garbage from \"./Garbage.js\";\r\nclass ZikoEventKey{\r\n    #downController\r\n    #pressController\r\n    #upController\r\n    #dispose\r\n    constructor(Target=window){ \r\n        this._Target=window\r\n        this.target(Target)\r\n        this.kp=null;\r\n        this.kd=null;\r\n        this.ku=null;\r\n        this.t=0;\r\n        this.cache={\r\n            preventDefault:{\r\n                down:false,\r\n                press:false,\r\n                up:false,\r\n            },\r\n            Enabled:{\r\n                down:false,\r\n                press:false,\r\n                up:false,\r\n            },\r\n            callback:{\r\n                down:[(self)=>console.log({kd:self.kd})],\r\n                press:[(self)=>console.log({kp:self.kp})],\r\n                up:[(self)=>console.log({ku:self.ku})]\r\n            },\r\n            successifKeysCallback:{\r\n                down:[(self)=>console.log(1111)],\r\n                press:[(self)=>console.log(1112)],\r\n                up:[(self)=>console.log(1113)]\r\n            },\r\n            down:[],\r\n            press:[],\r\n            up:[],\r\n        }\r\n        this.#downController=this._updateDown.bind(this);\r\n        this.#pressController=this._updatePress.bind(this);\r\n        this.#upController=this._updateUp.bind(this);\r\n        this.#dispose=this.dispose.bind(this);\r\n        this.EventIndex=Garbage.Key.data.length;\r\n        Garbage.Key.data.push({event:this,index:this.EventIndex});\r\n    }\r\n    target(UI){\r\n        if(typeof UI === \"string\")this._Target=document.querySelector(UI)\r\n        else this._Target=UI?.element||window;\r\n        return this;\r\n    }\r\n    _updateDown(e){\r\n        if(this.cache.preventDefault.down)e.preventDefault();\r\n        this.kd=e.key;\r\n        if(this.cache.Enabled.down)this.cache.down.push({key:this.kd,t:0});\r\n        this.cache.callback.down.map(n=>n(this))\r\n        return this;\r\n    } \r\n    handleDown(){\r\n        this.dispose({down:true,press:false,up:false})\r\n        this._Target.addEventListener(\"keydown\",this.#downController);\r\n        return this;\r\n     }\r\n     _updatePress(e){\r\n        if(this.cache.preventDefault.press)e.preventDefault();\r\n        this.kp=e.key;\r\n        if(this.cache.Enabled.press)this.cache.press.push({key:this.kp,t:0});\r\n        this.cache.callback.press.map(n=>n(this))\r\n        return this;\r\n    }\r\n    handlePress(){\r\n        this.dispose({down:false,up:false})\r\n        this._Target.addEventListener(\"keypress\",this.#pressController);\r\n        return this;\r\n    }\r\n    _updateUp(e){\r\n        if(this.cache.preventDefault.up)e.preventDefault();\r\n        this.ku=e.key;\r\n        if(this.cache.Enabled.up)this.cache.up.push({key:this.ku,t:0});\r\n        this.cache.callback.up.map(n=>n(this))\r\n        return this;\r\n    }\r\n    handleUp(){\r\n        this.dispose({press:false,down:false})\r\n        this._Target.addEventListener(\"keyup\",this.#upController);\r\n        return this;\r\n    }\r\n    handle({down=true,press=true,up=true}={}){\r\n        if(down)this.handleDown();\r\n        if(press)this.handlePress();\r\n        if(up)this.handleUp();\r\n        return this;\r\n    }\r\n    dispose({down=true,press=true,up=true}={}){\r\n        if(down)this._Target.removeEventListener(\"keydown\",this.#downController);\r\n        if(press)this._Target.removeEventListener(\"keypress\",this.#pressController);\r\n        if(up)this._Target.removeEventListener(\"keyup\",this.#upController);\r\n        return this;\r\n    }\r\n    memorize({down=true,press=true,up=true}={}){\r\n        Object.assign(this.cache.Enabled,{down,press,up});\r\n        return this;\r\n    }\r\n    clear({down=true,press=true,up=true}={}){\r\n        if(down)this.cache.down=[];\r\n        if(press)this.cache.press=[];\r\n        if(up)this.cache.up=[];\r\n        return this;\r\n    }\r\n    preventDefault({down=true,press=true,up=true}={}){\r\n        Object.assign(this.cache.preventDefault,{down,press,up});\r\n        return this;\r\n     }\r\n    onDown(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.down=callback.map(n=>e=>n.call(this,e))\r\n        return this;\r\n     }\r\n    onPress(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.press=callback.map(n=>e=>n.call(this,e))\r\n        return this;\r\n     }\r\n    onUp(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.up=callback.map(n=>e=>n.call(this,e))\r\n        return this;\r\n     }\r\n    handleSuccessifKeys({keys=[],callback=()=>console.log(1),event={down:true,press:false,up:false}}={}){\r\n        const reversedkeys = keys.reverse();\r\n        const newkeys = new Array(reversedkeys.length).fill(null);\r\n        //console.log({reversedkeys,newkeys})\r\n        const addsub = (arr, item, length = keys.length) => {\r\n            arr.unshift(item);\r\n            arr.length = length;\r\n          };\r\n        \r\n        if(event.down){\r\n            this.handleDown();\r\n            this.cache.successifKeysCallback.down=[callback];\r\n            this.cache.callback.down.push(e=>{\r\n                addsub(newkeys,e.kd);\r\n                if(JSON.stringify(reversedkeys)===JSON.stringify(newkeys))this.cache.successifKeysCallback.down.map(n=>n(this))\r\n                //console.log(JSON.stringify(reversedkeys)===JSON.stringify(newkeys))\r\n            })        \r\n            }       \r\n     }\r\n\r\n}\r\n\r\nvar Key=Target=>new ZikoEventKey(Target)\r\nexport default Key",
  "Events_Key_js_stats_length": 5382,
  "Events_Key_js_stats_size": 5.255859375,
  "Events_Key_js_stats_lines": 152,
  "Events_Key_js_metadata_permissions": 33206,
  "Events_Observer_js_content": "class ZikoMutationObserver {\r\n    constructor(UIElement, options) {\r\n      this.UIElement = UIElement;\r\n      this.options = options || { attributes: true, childList: true, subtree: true };\r\n      this.observer = null;\r\n      this.streamingEnabled = false;\r\n      this.mutationHistory = {\r\n        attributes: [],\r\n        childList: [],\r\n        subtree: [],\r\n      };\r\n  \r\n      this.observeCallback = (mutationsList, observer) => {\r\n        if (this.streamingEnabled) {\r\n          for (const mutation of mutationsList) {\r\n            if (mutation.type === 'attributes') {\r\n              this.mutationHistory.attributes.push(mutation);\r\n            } else if (mutation.type === 'childList') {\r\n              this.mutationHistory.childList.push(mutation);\r\n            } else if (mutation.type === 'subtree') {\r\n              this.mutationHistory.subtree.push(mutation);\r\n            }\r\n          }\r\n        }\r\n        if (this.callback) {\r\n          this.callback(mutationsList, observer);\r\n        }\r\n      };\r\n    }\r\n  \r\n    observe(callback) {\r\n      if (!this.observer) {\r\n        this.observer = new MutationObserver(this.observeCallback);\r\n        this.observer.observe(this.UIElement, this.options);\r\n        this.callback = callback;\r\n        this.streamingEnabled = true;\r\n      }\r\n    }\r\n  \r\n    pause(options) {\r\n      if (this.observer) {\r\n        this.observer.disconnect();\r\n        if (options) {\r\n          this.observer.observe(this.UIElement, options);\r\n        }\r\n      }\r\n    }\r\n  \r\n    reset(options) {\r\n      if (this.observer) {\r\n        this.observer.disconnect();\r\n        this.observer.observe(this.UIElement, options || this.options);\r\n      }\r\n    }\r\n  \r\n    clear() {\r\n      if (this.observer) {\r\n        this.observer.disconnect();\r\n        this.observer = null;\r\n        this.mutationHistory = {\r\n          attributes: [],\r\n          childList: [],\r\n          subtree: [],\r\n        };\r\n      }\r\n      this.streamingEnabled = false;\r\n    }\r\n  \r\n    getMutationHistory() {\r\n      return this.mutationHistory;\r\n    }\r\n  \r\n    enableStreaming() {\r\n      this.streamingEnabled = true;\r\n    }\r\n  \r\n    disableStreaming() {\r\n      this.streamingEnabled = false;\r\n    }\r\n  }\r\n",
  "Events_Observer_js_stats_length": 2201,
  "Events_Observer_js_stats_size": 2.1494140625,
  "Events_Observer_js_stats_lines": 81,
  "Events_Observer_js_metadata_permissions": 33206,
  "Events_Pointer_js_content": "import Garbage from \"./Garbage.js\"\r\nclass ZikoEventPointer{\r\n        #downController\r\n        #moveController\r\n        #upController\r\n        #enterController\r\n        #outController\r\n        #leaveController\r\n        #dispose\r\n    constructor(target){\r\n        this._Target=window;\r\n        this.event=null;\r\n        this.dx=0;\r\n        this.dy=0;\r\n        this.dt=0;\r\n        this.mx=0;\r\n        this.my=0;\r\n        this.mt=0;\r\n        this.ux=0;\r\n        this.uy=0;      \r\n        this.ut=0;\r\n        this.isMoving=false;\r\n        this.isDown=false;\r\n        this.cache={\r\n            preventDefault:{\r\n                down:false,\r\n                move:false,\r\n                up:false,\r\n                enter:false,\r\n                out:false,\r\n                leave:false,\r\n            },\r\n            Enabled:{\r\n                down:false,\r\n                move:false,\r\n                up:false,\r\n                enter:false,\r\n                out:false,\r\n                leave:false,\r\n            },\r\n            callback:{\r\n                down:[(self)=>console.log({dx:self.dx,dy:self.dy,down:self.down,move:self.move,t:self.dt})],\r\n                move:[(self)=>console.log({mx:self.mx,my:self.my,down:self.down,move:self.move,t:self.dt})],\r\n                up:[(self)=>console.log({ux:self.ux,uy:self.uy,down:self.down,move:self.move,t:self.dt})],\r\n                enter:[(self)=>console.log({dx:self.dx,dy:self.dy,down:self.down,move:self.move,t:self.dt})],\r\n                out:[(self)=>console.log({mx:self.mx,my:self.my,down:self.down,move:self.move,t:self.dt})],\r\n                leave:[(self)=>console.log({ux:self.ux,uy:self.uy,down:self.down,move:self.move,t:self.dt})]\r\n            },\r\n            down:[],\r\n            move:[],\r\n            up:[],\r\n            enter:[],\r\n            out:[],\r\n            leave:[]\r\n        }\r\n        this.#downController=this.#updateDown.bind(this);\r\n        this.#moveController=this.#updateMove.bind(this);\r\n        this.#upController=this.#updateUp.bind(this);\r\n        this.#enterController=this.#updateEnter.bind(this);\r\n        this.#outController=this.#updateOut.bind(this);\r\n        this.#leaveController=this.#updateLeave.bind(this);\r\n        this.#dispose=this.dispose.bind(this);\r\n        this.EventIndex=Garbage.Pointer.data.length;\r\n        Garbage.Pointer.data.push({event:this,index:this.EventIndex});\r\n        this.target(target);\r\n    }\r\n    target(UI){\r\n        this._Target=UI?.element||document.querySelector(UI);\r\n        return this;\r\n    }\r\n    #updateDown(e){\r\n        this.event=e\r\n        if(this.cache.preventDefault.down)e.preventDefault();\r\n        this.dx=parseInt(e.offsetX);\r\n        this.dy=parseInt(e.offsetY);\r\n        this.isDown=true;\r\n        if(this.cache.Enabled.down)this.cache.down.push({x:this.dx,y:this.dy});\r\n        this.cache.callback.down.map(n=>n(this));\r\n        return this;\r\n    }\r\n    handleDown(){\r\n       this._Target.addEventListener(\"pointerdown\",this.#downController);\r\n       return this;\r\n    }\r\n    #updateMove(e){\r\n        this.event=e;\r\n        if(this.cache.preventDefault.move)e.preventDefault();\r\n        this.mx=parseInt(e.offsetX);\r\n        this.my=parseInt(e.offsetY);\r\n        this.isMoving=true;\r\n        if(this.cache.Enabled.move)this.cache.move.push({x:this.mx,y:this.my,down:this.isDown,t:this.mt});\r\n        this.cache.callback.move.map(n=>n(this)); \r\n        return this;\r\n        \r\n    }\r\n    handleMove(){\r\n       this._Target.addEventListener(\"pointermove\",this.#moveController);\r\n       return this;\r\n    }\r\n    #updateUp(e){\r\n        this.event=e;\r\n        if(this.cache.preventDefault.up)e.preventDefault();\r\n        this.ux=parseInt(e.offsetX);\r\n        this.uy=parseInt(e.offsetY);\r\n        this.isDown=false;\r\n        if(this.cache.Enabled.up)this.cache.up.push({x:this.ux,y:this.uy,t:this.ut});\r\n        this.cache.callback.up.map(n=>n(this)); \r\n        return Pointer;\r\n    }\r\n    handleUp(){\r\n       this._Target.addEventListener(\"pointerup\",this.#upController);\r\n       return this;\r\n    }\r\n    #updateEnter(e){\r\n        this.event=e;\r\n        if(this.cache.preventDefault.up)e.preventDefault();\r\n        this.ux=parseInt(e.offsetX);\r\n        this.uy=parseInt(e.offsetY);\r\n        this.isDown=false;\r\n        if(this.cache.Enabled.enter)this.cache.enter.push({x:this.ux,y:this.uy,t:this.ut});\r\n        this.cache.callback.enter.map(n=>n(this)); \r\n        return Pointer;\r\n    }\r\n    handleEnter(){\r\n       this._Target.addEventListener(\"pointerenter\",this.#enterController);\r\n       return this;\r\n    }\r\n    #updateOut(e){\r\n        this.event=e;\r\n        if(this.cache.preventDefault.up)e.preventDefault();\r\n        this.ux=parseInt(e.offsetX);\r\n        this.uy=parseInt(e.offsetY);\r\n        this.isDown=false;\r\n        if(this.cache.Enabled.out)this.cache.out.push({x:this.ux,y:this.uy,t:this.ut});\r\n        this.cache.callback.out.map(n=>n(this)); \r\n        return Pointer;\r\n    }\r\n    handleOut(){\r\n       this._Target.addEventListener(\"pointerout\",this.#outController);\r\n       return this;\r\n    }\r\n    #updateLeave(e){\r\n        this.event=e;\r\n        if(this.cache.preventDefault.up)e.preventDefault();\r\n        this.ux=parseInt(e.offsetX);\r\n        this.uy=parseInt(e.offsetY);\r\n        this.isDown=false;\r\n        if(this.cache.Enabled.leave)this.cache.leave.push({x:this.ux,y:this.uy,t:this.ut});\r\n        this.cache.callback.leave.map(n=>n(this)); \r\n        return Pointer;\r\n    }\r\n    handleLeave(){\r\n       this._Target.addEventListener(\"pointerleave\",this.#leaveController);\r\n       return this;\r\n    }\r\n    handle({down=false,move=false,up=false}={}){\r\n        if(down)this.handleDown();\r\n        if(move)this.handleMove();\r\n        if(up)this.handleUp()\r\n    }\r\n    dispose({down=true,move=true,up=true,enter=true,out=true,leave=true}={}){\r\n        if(down)this._Target.removeEventListener(\"pointerdown\",this.#downController);\r\n        if(move)this._Target.removeEventListener(\"pointermove\",this.#moveController);\r\n        if(up)this._Target.removeEventListener(\"pointerup\",this.#upController);\r\n        if(enter)this._Target.removeEventListener(\"pointerenter\",this.#enterController);\r\n        if(out)this._Target.removeEventListener(\"pointerout\",this.#outController);\r\n        if(leave)this._Target.removeEventListener(\"pointerleave\",this.#leaveController);\r\n        return this;\r\n     }\r\n    stream({down=true,move=true,up=true,enter=true,out=true,leave=true}={}){\r\n        Object.assign(this.cache.Enabled,{down,move,up,enter,out,leave});\r\n        return this;\r\n     }\r\n    clear({down=true,move=true,up=true,enter=true,out=true,leave=true}={}){\r\n        if(down)this.cache.down=[];\r\n        if(move)this.cache.move=[];\r\n        if(up)this.cache.up=[];\r\n        if(enter)this.cache.enter=[];\r\n        if(out)this.cache.out=[];\r\n        if(leave)this.cache.leave=[];\r\n        return this;\r\n    }\r\n     preventDefault({down=true,move=true,up=true,enter=true,out=true,leave=true}={}){\r\n        Object.assign(this.cache.preventDefault,{down,move,up,enter,out,leave});\r\n        return this;\r\n     }\r\n     onDown(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.down=callback.map(n=>e=>n.call(this,e));\r\n        return this;\r\n     }\r\n     onMove(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.move=callback.map(n=>e=>n.call(this,e));\r\n        return this;\r\n     }\r\n     onUp(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.up=callback.map(n=>e=>n.call(this,e));\r\n        return this;\r\n     }\r\n     onEnter(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.enter=callback.map(n=>e=>n.call(this,e));\r\n        return this;\r\n     }\r\n     onOut(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.out=callback.map(n=>e=>n.call(this,e));\r\n        return this;\r\n     }\r\n     onLeave(...callback){\r\n        if(callback.length===0)return this;\r\n        this.cache.callback.leave=callback.map(n=>e=>n.call(this,e));\r\n        return this;\r\n     }\r\n}\r\nvar Pointer=target=>new ZikoEventPointer(target)\r\nexport default Pointer\r\n\r\n/*\r\nPointer._Target=document.querySelector(\".input\")\r\nPointer.handleDown()\r\nPointer.handleMove()\r\nPointer.handleUp()\r\n*/",
  "Events_Pointer_js_stats_length": 8285,
  "Events_Pointer_js_stats_size": 8.0908203125,
  "Events_Pointer_js_stats_lines": 226,
  "Events_Pointer_js_metadata_permissions": 33206,
  "Graphics_Canvas_Filter_index_js_content": "",
  "Graphics_Canvas_Filter_index_js_stats_length": 0,
  "Graphics_Canvas_Filter_index_js_stats_size": 0,
  "Graphics_Canvas_Filter_index_js_stats_lines": 1,
  "Graphics_Canvas_Filter_index_js_metadata_permissions": 33206,
  "Graphics_Canvas_Paint_index_js_content": "",
  "Graphics_Canvas_Paint_index_js_stats_length": 0,
  "Graphics_Canvas_Paint_index_js_stats_size": 0,
  "Graphics_Canvas_Paint_index_js_stats_lines": 1,
  "Graphics_Canvas_Paint_index_js_metadata_permissions": 33206,
  "Graphics_Canvas_Utils_floodFill_js_content": "const floodFill=(parent, imageData, newColor, x, y)=>{\r\n    const { width, height, data } = imageData;\r\n    const stack = [];\r\n    const baseColor = parent.getColorAtPixel(imageData, x, y);\r\n    let operator = { x, y };\r\n\r\n    // Check if base color and new color are the same\r\n    if (parent.colorMatch(baseColor, newColor)) {\r\n        return;\r\n    }\r\n\r\n    // Add the clicked location to stack\r\n    stack.push({ x: operator.x, y: operator.y });\r\n\r\n    while (stack.length) {\r\n        operator = stack.pop();\r\n        let contiguousDown = true; // Vertical is assumed to be true\r\n        let contiguousUp = true; // Vertical is assumed to be true\r\n        let contiguousLeft = false;\r\n        let contiguousRight = false;\r\n\r\n        // Move to top most contiguousDown pixel\r\n        while (contiguousUp && operator.y >= 0) {\r\n            operator.y--;\r\n            contiguousUp = parent.colorMatch(parent.getColorAtPixel(imageData, operator.x, operator.y), baseColor);\r\n        }\r\n\r\n        // Move downward\r\n        while (contiguousDown && operator.y < height) {\r\n            parent.setColorAtPixel(imageData, newColor, operator.x, operator.y);\r\n\r\n            // Check left\r\n            if (operator.x - 1 >= 0 && parent.colorMatch(parent.getColorAtPixel(imageData, operator.x - 1, operator.y), baseColor)) {\r\n                if (!contiguousLeft) {\r\n                    contiguousLeft = true;\r\n                    stack.push({ x: operator.x - 1, y: operator.y });\r\n                }\r\n            } else {\r\n                contiguousLeft = false;\r\n            }\r\n\r\n            // Check right\r\n            if (operator.x + 1 < width && parent.colorMatch(parent.getColorAtPixel(imageData, operator.x + 1, operator.y), baseColor)) {\r\n                if (!contiguousRight) {\r\n                    stack.push({ x: operator.x + 1, y: operator.y });\r\n                    contiguousRight = true;\r\n                }\r\n            } else {\r\n                contiguousRight = false;\r\n            }\r\n\r\n            operator.y++;\r\n            contiguousDown = parent.colorMatch(parent.getColorAtPixel(imageData, operator.x, operator.y), baseColor);\r\n        }\r\n    }\r\n    return imageData;\r\n}\r\nexport default floodFill;",
  "Graphics_Canvas_Utils_floodFill_js_stats_length": 2205,
  "Graphics_Canvas_Utils_floodFill_js_stats_size": 2.1533203125,
  "Graphics_Canvas_Utils_floodFill_js_stats_lines": 58,
  "Graphics_Canvas_Utils_floodFill_js_metadata_permissions": 33206,
  "Graphics_Canvas_canvas_js_content": "",
  "Graphics_Canvas_canvas_js_stats_length": 0,
  "Graphics_Canvas_canvas_js_stats_size": 0,
  "Graphics_Canvas_canvas_js_stats_lines": 1,
  "Graphics_Canvas_canvas_js_metadata_permissions": 33206,
  "Graphics_Canvas_index_js_content": "",
  "Graphics_Canvas_index_js_stats_length": 0,
  "Graphics_Canvas_index_js_stats_size": 0,
  "Graphics_Canvas_index_js_stats_lines": 1,
  "Graphics_Canvas_index_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_circle_js_content": "",
  "Graphics_Svg_Elements_circle_js_stats_length": 0,
  "Graphics_Svg_Elements_circle_js_stats_size": 0,
  "Graphics_Svg_Elements_circle_js_stats_lines": 1,
  "Graphics_Svg_Elements_circle_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_ellips_js_content": "",
  "Graphics_Svg_Elements_ellips_js_stats_length": 0,
  "Graphics_Svg_Elements_ellips_js_stats_size": 0,
  "Graphics_Svg_Elements_ellips_js_stats_lines": 1,
  "Graphics_Svg_Elements_ellips_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_foreignObject_js_content": "",
  "Graphics_Svg_Elements_foreignObject_js_stats_length": 0,
  "Graphics_Svg_Elements_foreignObject_js_stats_size": 0,
  "Graphics_Svg_Elements_foreignObject_js_stats_lines": 1,
  "Graphics_Svg_Elements_foreignObject_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_groupe_js_content": "",
  "Graphics_Svg_Elements_groupe_js_stats_length": 0,
  "Graphics_Svg_Elements_groupe_js_stats_size": 0,
  "Graphics_Svg_Elements_groupe_js_stats_lines": 1,
  "Graphics_Svg_Elements_groupe_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_image_js_content": "",
  "Graphics_Svg_Elements_image_js_stats_length": 0,
  "Graphics_Svg_Elements_image_js_stats_size": 0,
  "Graphics_Svg_Elements_image_js_stats_lines": 1,
  "Graphics_Svg_Elements_image_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_line_js_content": "",
  "Graphics_Svg_Elements_line_js_stats_length": 0,
  "Graphics_Svg_Elements_line_js_stats_size": 0,
  "Graphics_Svg_Elements_line_js_stats_lines": 1,
  "Graphics_Svg_Elements_line_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_path_js_content": "",
  "Graphics_Svg_Elements_path_js_stats_length": 0,
  "Graphics_Svg_Elements_path_js_stats_size": 0,
  "Graphics_Svg_Elements_path_js_stats_lines": 1,
  "Graphics_Svg_Elements_path_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_polygone_js_content": "",
  "Graphics_Svg_Elements_polygone_js_stats_length": 0,
  "Graphics_Svg_Elements_polygone_js_stats_size": 0,
  "Graphics_Svg_Elements_polygone_js_stats_lines": 1,
  "Graphics_Svg_Elements_polygone_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_polyline_js_content": "",
  "Graphics_Svg_Elements_polyline_js_stats_length": 0,
  "Graphics_Svg_Elements_polyline_js_stats_size": 0,
  "Graphics_Svg_Elements_polyline_js_stats_lines": 1,
  "Graphics_Svg_Elements_polyline_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_rect_js_content": "",
  "Graphics_Svg_Elements_rect_js_stats_length": 0,
  "Graphics_Svg_Elements_rect_js_stats_size": 0,
  "Graphics_Svg_Elements_rect_js_stats_lines": 1,
  "Graphics_Svg_Elements_rect_js_metadata_permissions": 33206,
  "Graphics_Svg_Elements_text_js_content": "",
  "Graphics_Svg_Elements_text_js_stats_length": 0,
  "Graphics_Svg_Elements_text_js_stats_size": 0,
  "Graphics_Svg_Elements_text_js_stats_lines": 1,
  "Graphics_Svg_Elements_text_js_metadata_permissions": 33206,
  "Graphics_Svg_index_js_content": "",
  "Graphics_Svg_index_js_stats_length": 0,
  "Graphics_Svg_index_js_stats_size": 0,
  "Graphics_Svg_index_js_stats_lines": 1,
  "Graphics_Svg_index_js_metadata_permissions": 33206,
  "Graphics_Svg_svg_js_content": "",
  "Graphics_Svg_svg_js_stats_length": 0,
  "Graphics_Svg_svg_js_stats_size": 0,
  "Graphics_Svg_svg_js_stats_lines": 1,
  "Graphics_Svg_svg_js_metadata_permissions": 33206,
  "Graphics_index_js_content": "",
  "Graphics_index_js_stats_length": 0,
  "Graphics_index_js_stats_size": 0,
  "Graphics_index_js_stats_lines": 1,
  "Graphics_index_js_metadata_permissions": 33206,
  "Interfacing_Capacitor_index_js_content": "\r\n",
  "Interfacing_Capacitor_index_js_stats_length": 2,
  "Interfacing_Capacitor_index_js_stats_size": 0.001953125,
  "Interfacing_Capacitor_index_js_stats_lines": 2,
  "Interfacing_Capacitor_index_js_metadata_permissions": 33206,
  "Interfacing_Electron_index_js_content": "\r\n",
  "Interfacing_Electron_index_js_stats_length": 2,
  "Interfacing_Electron_index_js_stats_size": 0.001953125,
  "Interfacing_Electron_index_js_stats_lines": 2,
  "Interfacing_Electron_index_js_metadata_permissions": 33206,
  "Interfacing_Johnny Five_index_js_content": "\r\n",
  "Interfacing_Johnny Five_index_js_stats_length": 2,
  "Interfacing_Johnny Five_index_js_stats_size": 0.001953125,
  "Interfacing_Johnny Five_index_js_stats_lines": 2,
  "Interfacing_Johnny Five_index_js_metadata_permissions": 33206,
  "Interfacing_React_index_js_content": "\r\n",
  "Interfacing_React_index_js_stats_length": 2,
  "Interfacing_React_index_js_stats_size": 0.001953125,
  "Interfacing_React_index_js_stats_lines": 2,
  "Interfacing_React_index_js_metadata_permissions": 33206,
  "Interfacing_React Native_index_js_content": "\r\n",
  "Interfacing_React Native_index_js_stats_length": 2,
  "Interfacing_React Native_index_js_stats_size": 0.001953125,
  "Interfacing_React Native_index_js_stats_lines": 2,
  "Interfacing_React Native_index_js_metadata_permissions": 33206,
  "Interfacing_Streamlit_index_py_content": "\r\n",
  "Interfacing_Streamlit_index_py_stats_length": 2,
  "Interfacing_Streamlit_index_py_stats_size": 0.001953125,
  "Interfacing_Streamlit_index_py_stats_lines": 2,
  "Interfacing_Streamlit_index_py_metadata_permissions": 33206,
  "Math_Complex_Docs_Reference_md_content": "\r\n",
  "Math_Complex_Docs_Reference_md_stats_length": 2,
  "Math_Complex_Docs_Reference_md_stats_size": 0.001953125,
  "Math_Complex_Docs_Reference_md_stats_lines": 2,
  "Math_Complex_Docs_Reference_md_metadata_permissions": 33206,
  "Math_Complex_Docs_To do_md_content": "## Get \r\n|Methode|Description|isVerified|\r\n|-|-|-|\r\n| `clone`||✅|\r\n| `z`||✅|\r\n| `phi`||✅|\r\n| `conj`||✅|\r\n| `inv`||✅|\r\n|`expo`||✅|\r\n| `sqrt`||✅|\r\n| `log`||✅|\r\n| `cos`||✅|\r\n| `sin`||✅|\r\n| `tan`||✅|\r\n## Static get \r\n|Methode|Description|isVerified|\r\n|-|-|-|\r\n| `ZERO`||✅|\r\n## Methodes\r\n|Methode|Description|dynamique|static|comment|\r\n|-|-|-|-|-|\r\n| `add`||✅|✅||\r\n| `sub`||✅|✅||\r\n| `mul`||✅|✅||\r\n| `div`||✅|✅||\r\n| `pow`||✅|✅||\r\n| `xpowZ`|||||\r\n| `sqrt`|||||\r\n| `sqrtn`|||||\r\n\r\n",
  "Math_Complex_Docs_To do_md_stats_length": 517,
  "Math_Complex_Docs_To do_md_stats_size": 0.5048828125,
  "Math_Complex_Docs_To do_md_stats_lines": 31,
  "Math_Complex_Docs_To do_md_metadata_permissions": 33206,
  "Math_Complex_Fractals_julia_js_content": "",
  "Math_Complex_Fractals_julia_js_stats_length": 0,
  "Math_Complex_Fractals_julia_js_stats_size": 0,
  "Math_Complex_Fractals_julia_js_stats_lines": 1,
  "Math_Complex_Fractals_julia_js_metadata_permissions": 33206,
  "Math_Complex_index_js_content": "import AbstractZikoMath from \"../absract.js\";\r\nimport{\r\n    cos,\r\n    sin,\r\n    tan,\r\n    pow,\r\n    //atan,\r\n    floor,\r\n    hypot,\r\n    cosh,\r\n    sinh,\r\n    sqrtn,\r\n    atan2,\r\n    sqrt,\r\n    ln\r\n  }from \"../Functions/index.js\"\r\nimport { Matrix } from \"../Matrix/index.js\";\r\nimport {sum,prod,deg2rad} from \"../Utils/index.js\";\r\n//import ZMath from \"./index.js\";\r\nclass Complex extends AbstractZikoMath{\r\n    constructor(a = 0, b = 0) {\r\n        super()\r\n        if(a instanceof Complex){\r\n            this.a=a.a;\r\n            this.b=a.b;\r\n        }\r\n        if(typeof(a)===\"object\"){\r\n            if((\"a\" in b && \"b\" in a)){\r\n                this.a=a.a;\r\n                this.b=a.b;\r\n            }\r\n            else if((\"a\" in b && \"z\" in a)){\r\n                this.a=a.a;\r\n                this.b=sqrt((a.z**2)-(a.a**2));\r\n            }\r\n            else if((\"a\" in b && \"phi\" in a)){\r\n                this.a=a.a;\r\n                this.b=a.a*tan(a.phi);\r\n            }\r\n            else if((\"b\" in b && \"z\" in a)){\r\n                this.b=a.b;\r\n                this.a=sqrt((a.z**2)-(a.b**2));\r\n            }\r\n            else if((\"b\" in b && \"phi\" in a)){\r\n                this.b=b;\r\n                this.a=a.b/tan(a.phi);\r\n            }\r\n            else if((\"z\" in b && \"phi\" in a)){\r\n                this.a=a.z*cos(a.phi);\r\n                this.a=a.z*sin(a.phi);\r\n            }\r\n        }\r\n        else if(typeof(a)===\"number\"&&typeof(b)===\"number\"){\r\n            this.a = +a.toFixed(32);\r\n            this.b = +b.toFixed(32);\r\n        }\r\n    }\r\n    get clone() {\r\n        return new Complex(this.a, this.b);\r\n    }\r\n    get z(){\r\n        return hypot(this.a,this.b);    \r\n    }\r\n    get phi(){\r\n        return atan2(this.b , this.a);        \r\n    }\r\n    static get ZERO() {\r\n        return new Complex(0, 0);\r\n    }\r\n    get conj() {\r\n        return new Complex(this.a, -this.b);\r\n    }\r\n    get inv() {\r\n        return new Complex(this.a / (pow(this.a, 2) + pow(this.b, 2)), -this.b / (pow(this.a, 2) + pow(this.b, 2)));\r\n    }\r\n    add(...z) {\r\n        for (let i = 0; i < z.length; i++) {\r\n            if (typeof z[i] === \"number\") z[i] = new Complex(z[i], 0);\r\n        }\r\n        let re = z.map((n) => n.a);\r\n        let im = z.map((n) => n.b);\r\n        this.a+=+sum(...re).toFixed(15);\r\n        this.b+=+sum(...im).toFixed(15);\r\n        return this;\r\n    }\r\n    sub(...z) {\r\n        for (let i = 0; i < z.length; i++) {\r\n            if (typeof z[i] === \"number\") z[i] = new Complex(z[i], 0);\r\n        }\r\n        let re = z.map((n) => n.a);\r\n        let im = z.map((n) => n.b);\r\n        this.a-=+sum(...re).toFixed(15);\r\n        this.b-=+sum(...im).toFixed(15);\r\n        return this;\r\n    }\r\n    mul(...z){\r\n        for (let i = 0; i < z.length; i++) {\r\n            if (typeof z[i] === \"number\") z[i] = new Complex(z[i], 0);\r\n        }\r\n        let Z=+prod(this.z,...z.map(n=>n.z)).toFixed(15);\r\n        let phi=+sum(this.phi,...z.map(n=>n.phi)).toFixed(15);\r\n        this.a=+(Z*cos(phi).toFixed(15)).toFixed(14);\r\n        this.b=+(Z*sin(phi).toFixed(15)).toFixed(14);    \r\n        return this;\r\n    }\r\n    div(...z) {\r\n        for (let i = 0; i < z.length; i++) {\r\n            if (typeof z[i] === \"number\") z[i] = new Complex(z[i], 0);\r\n        }\r\n        let Z=+(this.z/prod(...z.map(n=>n.z))).toFixed(15);\r\n        let phi=+(this.phi-sum(...z.map(n=>n.phi))).toFixed(15);\r\n        this.a=+(Z*cos(phi).toFixed(15)).toFixed(15);\r\n        this.b=+(Z*sin(phi).toFixed(15)).toFixed(15);\r\n        return this;\r\n    }\r\n    pow(n) {\r\n        if (floor(n) === n && n > 0) {\r\n            let z=+(this.z**n).toFixed(15);\r\n            let phi=+(this.phi*n).toFixed(15);\r\n            this.a=+(z*cos(phi).toFixed(15)).toFixed(15);\r\n            this.b=+(z*sin(phi).toFixed(15)).toFixed(15);\r\n        }\r\n        return this;\r\n    }\r\n    static fromExpo(z, phi) {\r\n        return new Complex(z * cos(phi), z * sin(phi));\r\n    }\r\n    get expo() {\r\n        return [this.z, this.phi];\r\n    }\r\n    static add(c,...z) {\r\n        return c.clone.add(...z);\r\n    }\r\n    static sub(c,...z) {\r\n        return c.clone.sub(...z);\r\n    }\r\n    static mul(c,...z) {\r\n        return c.clone.mul(...z);\r\n    }\r\n    static div(c,...z) {\r\n        return c.clone.div(...z);\r\n    }\r\n    static pow(z,n){\r\n        return z.clone.pow(n);\r\n    }\r\n    static xpowZ(x){\r\n        return complex((x**this.a)*cos(this.b*ln(x)),(x**this.a)*sin(this.b*ln(x)));\r\n    }\r\n    sqrtn(n=2){\r\n        return complex(sqrtn(this.z,n)*cos(this.phi/n),sqrtn(this.z,n)*sin(this.phi/n));\r\n    }\r\n    get sqrt(){\r\n        return this.sqrtn(2);\r\n    }\r\n    get log(){\r\n        return complex(this.z,this.phi);\r\n    }\r\n    get cos(){\r\n        return complex(cos(this.a)*cosh(this.b),sin(this.a)*sinh(this.b))\r\n    }\r\n    get sin(){\r\n        return complex(sin(this.a)*cosh(this.b),cos(this.a)*sinh(this.b))\r\n    }\r\n    get tan(){\r\n        const de=cos(this.a*2)+cosh(this.b*2);\r\n        return complex(sin(2*this.a)/de,sinh(2*this.b)/de);\r\n    }\r\n    printInConsole() {\r\n        let string = this.a + \" + \" + this.b + \" * i\";\r\n        console.log(string);\r\n        return string;\r\n    }\r\n    print() {\r\n        //return text(this.a + \" + i * \" + this.b);\r\n    }\r\n    UI() {\r\n        return \"<span>\" + this.a + \" + i * \" + this.b + \"</span>\";\r\n    }\r\n}\r\n\r\nconst complex=(a,b)=>{\r\n    if((a instanceof Array||ArrayBuffer.isView(a)) && (b instanceof Array||ArrayBuffer.isView(a)))return a.map((n,i)=>complex(a[i],b[i]));\r\n    if(a instanceof Matrix && b instanceof Matrix){\r\n        if((a.shape[0]!==b.shape[0])||(a.shape[1]!==b.shape[1]))return Error(0)\r\n        const arr=a.arr.map((n,i)=>complex(a.arr[i],b.arr[i]))\r\n        return new Matrix(a.rows,a.cols,...arr)\r\n    }\r\n    return new Complex(a,b)\r\n}\r\nexport{complex,Complex}",
  "Math_Complex_index_js_stats_length": 5777,
  "Math_Complex_index_js_stats_size": 5.6416015625,
  "Math_Complex_index_js_stats_lines": 190,
  "Math_Complex_index_js_metadata_permissions": 33206,
  "Math_Discret_conversion_js_content": "import{Complex} from \"../Complex/index.js\";\r\nimport{Matrix}from \"../Matrix/index.js\"\r\nvar Base={\r\n    _mode:Number,\r\n    _map:function(func,number,toBase){\r\n        if (number instanceof Matrix)\r\n            return new Matrix(\r\n                number.rows,\r\n                number.cols,\r\n                number.arr.flat(1).map(n=>func(n,toBase))\r\n            );\r\n        else if (number instanceof Complex) return new Complex(func(number.a,toBase),func(number.b,toBase));\r\n        else if (number instanceof Array) return number.map((n) =>func(n,toBase));\r\n    },\r\n    dec2base(dec,base){\r\n        base<=10?this._mode=Number:this._mode=String\r\n        //this._mode=String\r\n        if (typeof dec === \"number\") return this._mode((dec >>> 0).toString(base));\r\n          return this._map(this.dec2base,dec,base)\r\n    },\r\n    dec2bin(dec){\r\n        return this.dec2base(dec,2);\r\n    },\r\n    dec2oct(dec){\r\n        return this.dec2base(dec,8);\r\n    },\r\n    dec2hex(dec){\r\n        return this.dec2base(dec,16);\r\n    },\r\n    bin2base(bin, base) {\r\n        return this.dec2base(this.bin2dec(bin),base)\r\n    },\r\n    bin2dec(bin){\r\n        return this._mode(\"0b\"+bin);\r\n    },\r\n    bin2oct(bin){\r\n        return this.bin2base(bin,8);\r\n    },\r\n    bin2hex(bin){\r\n        return this.bin2base(bin,16);\r\n    },\r\n    oct2dec(oct){\r\n        return this._mode(\"0o\"+oct);\r\n    },\r\n    oct2bin(oct){\r\n        return this.dec2bin(this.oct2dec(oct))\r\n    },\r\n    oct2hex(oct){\r\n        return this.dec2hex(this.oct2dec(oct))\r\n    },\r\n    oct2base(oct, base) {\r\n        return this.dec2base(this.oct2dec(oct),base)\r\n    },\r\n    hex2dec(hex){\r\n        return this._mode(\"0x\"+hex);\r\n    },\r\n    hex2bin(hex){\r\n        return this.dec2bin(this.hex2dec(hex))\r\n    },\r\n    hex2oct(hex){\r\n        return this.dec2oct(this.hex2dec(hex))\r\n    },\r\n    hex2base(hex, base) {\r\n        return this.dec2base(this.hex2dec(hex),base)\r\n    },\r\n    IEEE32toDec(Bin){\r\n        let IEEE32=Bin.split(\" \").join(\"\").padEnd(32,\"0\");\r\n        let s=IEEE32[0];\r\n        let e=2**(+(\"0b\"+IEEE32.slice(1,9))-127)\r\n        let m=IEEE32.slice(9,32).split(\"\").map(n=>+n)\r\n        let M=m.map((n,i)=>n*(2**(-i-1))).reduce((a,b)=>a+b,0);\r\n        let dec=(-1)**s*(1+M)*e;\r\n        return dec\r\n    },\r\n    IEEE64toDec(Bin){\r\n        let IEEE64=Bin.split(\" \").join(\"\").padEnd(64,\"0\");\r\n        let s=IEEE64[0];\r\n        let e=2**(+(\"0b\"+IEEE64.slice(1,12))-1023)\r\n        let m=IEEE64.slice(13,64).split(\"\").map(n=>+n)\r\n        let M=m.map((n,i)=>n*(2**(-i-1))).reduce((a,b)=>a+b,0);\r\n        let dec=(-1)**s*(1+M)*e;\r\n        return dec;\r\n    }\r\n}\r\n\r\nexport{Base}",
  "Math_Discret_conversion_js_stats_length": 2609,
  "Math_Discret_conversion_js_stats_size": 2.5478515625,
  "Math_Discret_conversion_js_stats_lines": 86,
  "Math_Discret_conversion_js_metadata_permissions": 33206,
  "Math_Discret_index_js_content": "\r\nimport{Complex} from \"../Complex/index.js\";\r\nimport{Matrix}from \"../Matrix/index.js\"\r\nimport{arange}from \"../Utils/index.js\"\r\n\r\n// class Logic1{\r\n//     static not(input) {\r\n//         if (typeof input === \"number\") return +!input;\r\n//         else if (input instanceof Matrix)\r\n//             return new Matrix(\r\n//                 input.rows,\r\n//                 input.cols,\r\n//                 input.arr.flat(1).map((n) => Logic.not(n))\r\n//             );\r\n//         else if (input instanceof Complex) return new Complex(Logic.not(input.a), Logic.not(input.b));\r\n//         else if (input instanceof Array) return input.map((n) => Logic.not(n));\r\n//     }\r\n//     static and(a, ...b) {\r\n//         if (typeof a === \"number\") return b.reduce((n, m) => (n &= m), a);\r\n//         else if (a instanceof Matrix)\r\n//             return new Matrix(\r\n//                 a.rows,\r\n//                 a.cols,\r\n//                 a.arr.flat(1).map((n) => Logic.and(n, b))\r\n//             );\r\n//         else if (a instanceof Complex) return new Complex(Logic.and(a.a, b), Logic.and(a.b, b));\r\n//         else if (a instanceof Array) return a.map((n) => Logic.and(n, b));\r\n//     }\r\n//     static or(a, ...b) {\r\n//         if (typeof a === \"number\") return b.reduce((n, m) => (n |= m), a);\r\n//         else if (a instanceof Matrix)\r\n//             return new Matrix(\r\n//                 a.rows,\r\n//                 a.cols,\r\n//                 a.arr.flat(1).map((n) => Logic.or(n, b))\r\n//             );\r\n//         else if (a instanceof Complex) return new Complex(Logic.and(a.a, b), Logic.or(a.b, b));\r\n//         else if (a instanceof Array) return a.map((n) => Logic.or(n, b));\r\n//     }\r\n//     static nand(a, ...b) {\r\n//         return Logic.not(Logic.and(a, b));\r\n//     }\r\n//     static nor(a, ...b) {\r\n//         return Logic.not(Logic.or(a, b));\r\n//     }\r\n//     static xor(a, ...b) {\r\n//         if (typeof a === \"number\") {\r\n//             const c = b.Count(1);\r\n//             switch (c) {\r\n//                 case 0:\r\n//                     return a;\r\n//                 case 1:\r\n//                     return Logic.not(a);\r\n//                 default:\r\n//                     return 0;\r\n//             }\r\n//         } else if (a instanceof Matrix)\r\n//             return new Matrix(\r\n//                 a.rows,\r\n//                 a.cols,\r\n//                 a.arr.flat(1).map((n) => Logic.xor(n, b))\r\n//             );\r\n//         else if (a instanceof Complex) return new Complex(Logic.and(a.a, b), Logic.xor(a.b, b));\r\n//         else if (a instanceof Array) return a.map((n) => Logic.xor(n, b));\r\n//     }\r\n//     static xnor(a, ...b) {\r\n//         return Logic.not(Logic.xor(a, b));\r\n//     }\r\n// }\r\n// class BaseConversion {\r\n//     constructor() {}\r\n//     static dec2base(dec, base) {\r\n//         if (typeof dec === \"number\") return (dec >>> 0).toString(base);\r\n//         else if (dec instanceof Matrix)\r\n//             return new Matrix(\r\n//                 dec.rows,\r\n//                 dec.cols,\r\n//                 dec.arr.flat(1).map((n) => (n >>> 0).toString(base))\r\n//             );\r\n//         else if (dec instanceof Complex) return new Complex((dec.a >>> 0).toString(base), (dec.b >>> 0).toString(base));\r\n//         else if (dec instanceof Array) return dec.map((n) => BaseConversion.dec2base(n, base));\r\n//     }\r\n//     static bin2base(bin, base) {\r\n//         if (typeof bin === \"number\") return parseInt(bin, 2).toString(base);\r\n//         else if (bin instanceof Matrix)\r\n//             return new Matrix(\r\n//                 bin.rows,\r\n//                 bin.cols,\r\n//                 bin.arr.flat(1).map((n) => parseInt(n, 2).toString(base))\r\n//             );\r\n//         else if (bin instanceof Complex) return new Complex(parseInt(bin.a, 2).toString(base), parseInt(bin.b, 2).toString(base));\r\n//         else if (bin instanceof Array) return bin.map((n) => BaseConversion.bin2base(n, base));\r\n//     }\r\n//     static oct2base(oct, base) {\r\n//         if (typeof oct === \"number\") return +parseInt(oct, 8).toString(base);\r\n//         else if (oct instanceof Matrix)\r\n//             return new Matrix(\r\n//                 oct.rows,\r\n//                 oct.cols,\r\n//                 oct.arr.flat(1).map((n) => parseInt(n, 8).toString(base))\r\n//             );\r\n//         else if (oct instanceof Complex) return new Complex(parseInt(oct.a, 8).toString(base), parseInt(oct.b, 8).toString(base));\r\n//         else if (oct instanceof Array) return oct.map((n) => BaseConversion.oct2base(n, base));\r\n\r\n//         //return oct instanceof Array?oct.map((n)=>parseInt(n,8).toString(base)):parseInt(bin,8).toString(base);\r\n//     }\r\n//     static hex2base(hex, base) {\r\n//         if (typeof hex === \"number\") return +parseInt(hex, 16).toString(base);\r\n//         else if (hex instanceof Matrix)\r\n//             return new Matrix(\r\n//                 hex.rows,\r\n//                 hex.cols,\r\n//                 hex.arr.flat(1).map((n) => parseInt(n, 16).toString(base))\r\n//             );\r\n//         else if (hex instanceof Complex) return new Complex(parseInt(hex.a, 16).toString(base), parseInt(hex.b, 16).toString(base));\r\n//         else if (hex instanceof Array) return hex.map((n) => BaseConversion.hex2base(n, base));\r\n//     }\r\n//     static bin2dec(bin) {\r\n//         //return bin instanceof Array?bin.map((n)=>bin2base(n,10)):bin2base(bin,10);\r\n\r\n//         if (typeof bin === \"number\") return +BaseConversion.bin2base(bin, 10);\r\n//         else if (bin instanceof Matrix)\r\n//             return new Matrix(\r\n//                 bin.rows,\r\n//                 bin.cols,\r\n//                 bin.arr.flat(1).map((n) => +BaseConversion.bin2base(n, 10))\r\n//             );\r\n//         else if (bin instanceof Complex) return new Complex(+BaseConversion.bin2base(bin.a, 10), +BaseConversion.bin2base(bin.b, 10));\r\n//         else if (bin instanceof Array) return bin.map((n) => BaseConversion.bin2dec(n));\r\n//     }\r\n//     static dec2bin(dec) {\r\n//         //return +BaseConversion.dec2base(dec,2);\r\n\r\n//         if (typeof dec === \"number\") return +BaseConversion.dec2base(dec, 2);\r\n//         else if (dec instanceof Matrix)\r\n//             return new Matrix(\r\n//                 dec.rows,\r\n//                 dec.cols,\r\n//                 dec.arr.flat(1).map((n) => +BaseConversion.dec2base(n, 2))\r\n//             );\r\n//         else if (dec instanceof Complex) return new Complex(+BaseConversion.dec2base(dec.a, 2), +BaseConversion.dec2base(dec.a, 2));\r\n//         else if (dec instanceof Array) return dec.map((n) => BaseConversion.dec2bin(n));\r\n//     }\r\n//     static dec2oct(dec) {\r\n//         if (typeof dec === \"number\") return +BaseConversion.dec2base(dec, 8);\r\n//         else if (dec instanceof Matrix)\r\n//             return new Matrix(\r\n//                 dec.rows,\r\n//                 dec.cols,\r\n//                 dec.arr.flat(1).map((n) => +BaseConversion.dec2base(n, 8))\r\n//             );\r\n//         else if (dec instanceof Complex) return new Complex(+BaseConversion.dec2base(dec.a, 8), +BaseConversion.dec2base(dec.a, 8));\r\n//         else if (dec instanceof Array) return dec.map((n) => BaseConversion.dec2oct(n));\r\n//     }\r\n//     static dec2hex(dec) {\r\n//         if (typeof dec === \"number\") return BaseConversion.dec2base(dec, 16);\r\n//         //else if(dec instanceof Matrix)return new Matrix(dec.rows,dec.cols,dec.arr.flat(1).map(n=>BaseConversion.dec2base(n,16)));\r\n//         //else if(dec instanceof Complex)return new Complex(BaseConversion.dec2base(dec.a,16),BaseConversion.dec2base(dec.a,16));\r\n//         else if (dec instanceof Array) return dec.map((n) => BaseConversion.dec2hex(n));\r\n//     }\r\n//     static IEEE32toDec(Bin){\r\n//         let IEEE32=Bin.split(\" \").join(\"\").padEnd(32,\"0\");\r\n//         let s=IEEE32[0];\r\n//         let e=2**(+(\"0b\"+IEEE32.slice(1,9))-127)\r\n//         let m=IEEE32.slice(9,32).split(\"\").map(n=>+n)\r\n//         let M=m.map((n,i)=>n*(2**(-i-1))).reduce((a,b)=>a+b,0);\r\n//         let dec=(-1)**s*(1+M)*e;\r\n//         return dec\r\n//     }\r\n//     static IEEE64toDec(Bin){\r\n//         let IEEE64=Bin.split(\" \").join(\"\").padEnd(64,\"0\");\r\n//         let s=IEEE64[0];\r\n//         let e=2**(+(\"0b\"+IEEE64.slice(1,12))-1023)\r\n//         let m=IEEE64.slice(13,64).split(\"\").map(n=>+n)\r\n//         let M=m.map((n,i)=>n*(2**(-i-1))).reduce((a,b)=>a+b,0);\r\n//         let dec=(-1)**s*(1+M)*e;\r\n//         return dec\r\n//     }\r\n// }\r\nclass Permutation {\r\n    static withDiscount(arr, l = arr.length) {\r\n        if (l === 1) {\r\n            return arr.map((n) => [n]);\r\n        }\r\n        const permutations = [];\r\n        let smallerPermutations;\r\n        smallerPermutations = this.withDiscount(arr, l - 1);\r\n        arr.forEach((currentOption) => {\r\n            smallerPermutations.forEach((smallerPermutation) => {\r\n                permutations.push([currentOption].concat(smallerPermutation));\r\n            });\r\n        });\r\n        return permutations;\r\n    }\r\n    static withoutDiscount(arr) {\r\n        const l = arr.length;\r\n        if (l === 1) {\r\n            return arr.map((n) => [n]);\r\n        }\r\n        const permutations = [];\r\n        const smallerPermutations = this.withoutDiscount(arr.slice(1));\r\n        const firstOption = arr[0];\r\n        for (let i = 0; i < smallerPermutations.length; i++) {\r\n            const smallerPermutation = smallerPermutations[i];\r\n            for (let j = 0; j <= smallerPermutation.length; j++) {\r\n                const permutationPrefix = smallerPermutation.slice(0, j);\r\n                const permutationSuffix = smallerPermutation.slice(j);\r\n                permutations.push(permutationPrefix.concat([firstOption], permutationSuffix));\r\n            }\r\n        }\r\n        return permutations;\r\n    }\r\n}\r\nclass Combinaison {\r\n    static withDiscount(comboOptions, comboLength) {\r\n        if (comboLength === 1) {\r\n            return comboOptions.map((comboOption) => [comboOption]);\r\n        }\r\n        // Init combinations array.\r\n        const combos = [];\r\n        // Remember characters one by one and concatenate them to combinations of smaller lengths.\r\n        // We don't extract elements here because the repetitions are allowed.\r\n        comboOptions.forEach((currentOption, optionIndex) => {\r\n            // Generate combinations of smaller size.\r\n            const smallerCombos = this.withDiscount(comboOptions.slice(optionIndex), comboLength - 1);\r\n            // Concatenate currentOption with all combinations of smaller size.\r\n            smallerCombos.forEach((smallerCombo) => {\r\n                combos.push([currentOption].concat(smallerCombo));\r\n            });\r\n        });\r\n        return combos;\r\n    }\r\n    static withoutDiscount(comboOptions, comboLength) {\r\n        // If the length of the combination is 1 then each element of the original array\r\n        // is a combination itself.\r\n        if (comboLength === 1) {\r\n            return comboOptions.map((comboOption) => [comboOption]);\r\n        }\r\n        // Init combinations array.\r\n        const combos = [];\r\n        // Extract characters one by one and concatenate them to combinations of smaller lengths.\r\n        // We need to extract them because we don't want to have repetitions after concatenation.\r\n        comboOptions.forEach((currentOption, optionIndex) => {\r\n            // Generate combinations of smaller size.\r\n            const smallerCombos = this.withoutDiscount(comboOptions.slice(optionIndex + 1), comboLength - 1);\r\n            // Concatenate currentOption with all combinations of smaller size.\r\n            smallerCombos.forEach((smallerCombo) => {\r\n                combos.push([currentOption].concat(smallerCombo));\r\n            });\r\n        });\r\n\r\n        return combos;\r\n    }\r\n}\r\nfunction PowerSet(originalSet) {\r\n    const subSets = [];\r\n    const numberOfCombinations = 2 ** originalSet.length;\r\n    for (let combinationIndex = 0; combinationIndex < numberOfCombinations; combinationIndex += 1) {\r\n        const subSet = [];\r\n        for (let setElementIndex = 0; setElementIndex < originalSet.length; setElementIndex += 1) {\r\n            if (combinationIndex & (1 << setElementIndex)) {\r\n                subSet.push(originalSet[setElementIndex]);\r\n            }\r\n        }\r\n        subSets.push(subSet);\r\n    }\r\n    return subSets;\r\n}\r\nvar subset = (...arr) => {\r\n    let list = arange(0, 2 ** arr.length, 1);\r\n    let bin = list.toBin.map((n) => n.padStart(arr.length, 0)).map((n) => n.split(\"\").map((n) => +n));\r\n    let sub = bin.map((n) => n.map((m, i) => (m = arr[i])));\r\n    for (let i = 0; i < sub.length; i++) for (let j = 0; j < sub[i].length; j++) sub[i][j] = { n: sub[i][j], m: bin[i][j] };\r\n    sub = sub.map((n) => n.filter((x) => x.m == 1));\r\n    sub = sub.map((n) => n.map((m) => m.n));\r\n    return sub;\r\n}\r\n\r\n//export {Logic,BaseConversion,Permutation,Combinaison,PowerSet,subset}\r\n\r\nimport {Logic} from \"./logic.js\";\r\nimport {Base} from \"./conversion.js\";\r\nvar Discret={\r\n    Logic,\r\n    Base,\r\n    Permutation,\r\n    Combinaison,\r\n    PowerSet,\r\n    subset\r\n}\r\nexport default Discret;\r\nexport{Logic,Base,Permutation,Combinaison,PowerSet,subset}",
  "Math_Discret_index_js_stats_length": 13117,
  "Math_Discret_index_js_stats_size": 12.8095703125,
  "Math_Discret_index_js_stats_lines": 292,
  "Math_Discret_index_js_metadata_permissions": 33206,
  "Math_Discret_logic_js_content": "import{Complex} from \"../Complex/index.js\";\r\nimport{Matrix}from \"../Matrix/index.js\"\r\n//import{arange}from \"../Utils/index.js\"\r\nconst Logic={\r\n    _mode:Number,\r\n    _map:function(func,a,b){\r\n        if (a instanceof Matrix)\r\n            return new Matrix(\r\n                a.rows,\r\n                a.cols,\r\n                a.arr.flat(1).map((n) => func(n, b))\r\n            );\r\n        else if (a instanceof Complex) return new Complex(func(a.a, b), func(a.b, b));\r\n        else if (a instanceof Array) return a.map((n) => func(n, b));      \r\n    },\r\n    not:function(input){\r\n        if([\"number\",\"boolean\"].includes(typeof input)) return Logic._mode(!input);\r\n        else return this._map(this.not,input)\r\n    },\r\n    and:function(a, ...b){\r\n        if([\"number\",\"boolean\"].includes(typeof a))return Logic._mode(b.reduce((n, m) => (n &= m), a));\r\n        else return this._map(this.and,a,b)\r\n    },\r\n    or:function(a, ...b) {\r\n        if([\"number\",\"boolean\"].includes(typeof a)) return Logic._mode(b.reduce((n, m) => (n |= m), a));\r\n        else return this._map(this.or,a,b);\r\n    },\r\n    nand:function(a, ...b) {\r\n        return this.not(this.and(a, b));\r\n    },\r\n    nor:function(a, ...b) {\r\n        return this.not(this.or(a, b));\r\n    },\r\n    xor:function(a,...b){\r\n        let arr=[a,...b]\r\n        if([\"number\",\"boolean\"].includes(typeof a))return this._mode(arr.reduce((length,cur)=>{\r\n            if(+cur===1)length+=1;\r\n            return length;\r\n        },0)===1);\r\n        else return this._map(this.xor,a,b);\r\n    },\r\n    xnor:function(a,...b){\r\n        return Logic.not(Logic.xor(a,b))\r\n    }\r\n    \r\n}\r\nexport{Logic}",
  "Math_Discret_logic_js_stats_length": 1635,
  "Math_Discret_logic_js_stats_size": 1.5966796875,
  "Math_Discret_logic_js_stats_lines": 47,
  "Math_Discret_logic_js_metadata_permissions": 33206,
  "Math_Functions_index_js_content": "import { mapFun } from \"./utils.js\";\r\n//import ZikoMath from \"./index.js\"\r\n//import{Matrix} from \"../Matrix/index.js\"\r\n//import{complex, Complex} from \"./Complex.js\"\r\n// var a=complex(1,1)\r\n// console.log(a instanceof Complex)\r\n//mapArgs=(fun,...args1)=>(...args2)=>new Array(args1.length).fill(null).map((n,i)=>fun(args1[i],args2[i]))\r\n\r\nfunction abs(...x){\r\n    return mapFun(Math.abs,...x);\r\n}\r\nfunction sqrt(...x){\r\n    return mapFun(Math.sqrt,...x);\r\n}\r\nfunction pow(...x){\r\n    //return n=>mapFun(a=>Math.pow(a,n),...x)\r\n    const n=x.pop();\r\n    return mapFun(a=>Math.pow(a,n),...x)\r\n}\r\nfunction sqrtn(...x){\r\n    const n=x.pop();\r\n    return mapFun(a=>e(ln(a) / n),...x)\r\n}\r\nfunction e(...x){\r\n    return mapFun(Math.exp,...x);\r\n}\r\nfunction ln(...x){\r\n    return mapFun(Math.log,...x);\r\n}\r\nfunction cos(...x){\r\n    return mapFun(a=>+Math.cos(a).toFixed(15),...x);\r\n}\r\nfunction sin(...x){\r\n    return mapFun(a=>+Math.sin(a).toFixed(15),...x);\r\n}\r\nfunction tan(...x){\r\n    return mapFun(a=>+Math.tan(a).toFixed(15),...x);\r\n}\r\nfunction sec(...x){\r\n    return mapFun(a=>+1/Math.cos(a).toFixed(15),...x);\r\n}\r\nfunction csc(...x){\r\n    return mapFun(a=>+1/Math.sin(a).toFixed(15),...x);\r\n}\r\nfunction cot(...x){\r\n    return mapFun(a=>+1/Math.tan(a).toFixed(15),...x);\r\n}\r\nfunction acos(...x){\r\n    return mapFun(a=>+Math.acos(a).toFixed(15),...x);\r\n}\r\nfunction asin(...x){\r\n    return mapFun(a=>+Math.asin(a).toFixed(15),...x);\r\n}\r\nfunction atan(...x){\r\n    return mapFun(a=>+Math.atan(a).toFixed(15),...x);\r\n}\r\nfunction acot(...x){\r\n    return mapFun(a=>+Math.PI/2-Math.atan(a).toFixed(15),...x);\r\n}\r\nfunction cosh(...x){\r\n    return mapFun(a=>+Math.cosh(a).toFixed(15),...x);\r\n}\r\nfunction sinh(...x){\r\n    return mapFun(a=>+Math.sinh(a).toFixed(15),...x);\r\n}\r\nfunction tanh(...x){\r\n    return mapFun(a=>+Math.tanh(a).toFixed(15),...x);\r\n}\r\nfunction coth(...x){\r\n    return mapFun(n=>+(1/2*Math.log((1+n)/(1-n))).toFixed(15),...x);\r\n}\r\nfunction acosh(...x){\r\n    return mapFun(a=>+Math.acosh(a).toFixed(15),...x);\r\n}\r\nfunction asinh(...x){\r\n    return mapFun(a=>+Math.asinh(a).toFixed(15),...x);\r\n}\r\nfunction atanh(...x){\r\n    return mapFun(a=>+Math.atanh(a).toFixed(15),...x);\r\n}\r\nfunction ceil(...x){\r\n    return mapFun(Math.ceil,...x);\r\n}\r\nfunction floor(...x){\r\n    return mapFun(Math.floor,...x);\r\n}\r\nfunction round(...x){\r\n    return mapFun(Math.round,...x);\r\n}\r\nfunction atan2(...x){\r\n    const n=x.pop();\r\n    return mapFun(a=>Math.atan2(a,n),...x)\r\n}\r\nfunction fact(...x){\r\n    return mapFun(n=> {\r\n        let i,\r\n        y = 1;\r\n        if (n == 0) y = 1;\r\n        else if (n > 0) for (i = 1; i <= n; i++) y *= i;\r\n        else y = NaN;\r\n        return y;\r\n    },...x);\r\n} \r\nfunction sign(...x){\r\n    return mapFun(Math.sign,...x);\r\n}\r\nfunction sig(...x){\r\n    return mapFun(n=>1/(1+e(-n)),...x);\r\n}\r\n\r\n\r\nvar min = (...x) => Math.min(...x);\r\nvar max = (...x) => Math.max(...x);\r\nvar hypot = Math.hypot;\r\nexport{\r\n    cos,\r\n    sin,\r\n    tan,\r\n    cot,\r\n    sec,\r\n    csc,\r\n    abs,\r\n    sqrt,\r\n    pow,\r\n    sqrtn,\r\n    e,\r\n    ln,\r\n    acos,\r\n    asin,\r\n    atan,\r\n    acot,\r\n    cosh,\r\n    sinh,\r\n    tanh,\r\n    coth,\r\n    acosh,\r\n    asinh,\r\n    atanh,\r\n    min,\r\n    max,\r\n    sign,\r\n    floor,\r\n    ceil,\r\n    round,\r\n    fact,\r\n    hypot,\r\n    sig,\r\n    atan2,\r\n  };",
  "Math_Functions_index_js_stats_length": 3284,
  "Math_Functions_index_js_stats_size": 3.20703125,
  "Math_Functions_index_js_stats_lines": 149,
  "Math_Functions_index_js_metadata_permissions": 33206,
  "Math_Functions_utils_js_content": "import { Matrix } from \"../Matrix/index.js\";\r\nimport { Complex , complex } from \"../Complex/index.js\";\r\nimport {ln,e,cos,sin,tan,abs,sqrt,cosh,sinh} from \"./index.js\"\r\nconst mapFun=(fun,...X)=>{\r\n    const Y=X.map(x=>{\r\n        if(x===null)return fun(null);\r\n        if([\"number\",\"string\",\"boolean\",\"bigint\",\"undefined\"].includes(typeof x))return fun(x);\r\n        if(x instanceof Array)return x.map(n=>mapFun(fun,n));\r\n        if(ArrayBuffer.isView(x))return x.map(n=>fun(n));\r\n        if(x instanceof Set)return new Set(mapFun(fun,...[...x]));\r\n        if(x instanceof Map)return new Map([...x].map(n=>[n[0],mapFun(fun,n[1])]));\r\n        if(x instanceof Matrix){\r\n            return new Matrix(x.rows,x.cols,mapFun(x.arr.flat(1)))\r\n        }\r\n        if(x instanceof Complex){\r\n            const [a,b,z,phi]=[x.a,x.b,x.z,x.phi];\r\n            switch(fun){\r\n                case Math.log:return complex(ln(z),phi);\r\n                case Math.exp:return complex(e(a)*cos(b),e(a)*sin(b));\r\n                case Math.abs:return z;\r\n                case Math.sqrt:return complex(sqrt(z)*cos(phi/2),sqrt(z)*sin(phi/2));\r\n                case Math.cos:return complex(cos(a)*cosh(b),-(sin(a)*sinh(b)));\r\n                case Math.sin:return complex(sin(a)*cosh(b),cos(a)*sinh(b));\r\n                case Math.tan:{\r\n                    const DEN=cos(2*a)+cosh(2*b);\r\n                    return complex(sin(2*a)/DEN,sinh(2*b)/DEN);\r\n                }\r\n                case Math.cosh:return complex(cosh(a)*cos(b),sinh(a)*sin(b));\r\n                case Math.sinh:return complex(sinh(a)*cos(b),cosh(a)*sin(b));\r\n                case Math.tanh:{\r\n                    const DEN=cosh(2*a)+cos(2*b);\r\n                    return complex(sinh(2*a)/DEN,sin(2*b)/DEN)\r\n                }\r\n                //default : return fun(x)\r\n            }\r\n        }\r\n        if(x instanceof Object)return Object.fromEntries(Object.entries(x).map(n=>n=[n[0],mapFun(fun,n[1])]))\r\n\r\n    });\r\n   return Y.length==1?Y[0]:Y; \r\n}\r\nexport {mapFun}",
  "Math_Functions_utils_js_stats_length": 2009,
  "Math_Functions_utils_js_stats_size": 1.9619140625,
  "Math_Functions_utils_js_stats_lines": 42,
  "Math_Functions_utils_js_metadata_permissions": 33206,
  "Math_Matrix_index_js_content": "import AbstractZikoMath from \"../absract.js\";\r\nimport{\r\n    pow,\r\n    min,\r\n    max,\r\n  } from \"../Functions/index.js\"\r\nimport { Utils } from \"../Utils/index.js\";\r\nimport { Complex } from \"../Complex/index.js\";\r\nimport {Random} from \"../Random/index.js\"\r\n//import { Logic } from \"./Discret/index.js\"\r\n//import Math from \"./index.js\";\r\nclass Matrix extends AbstractZikoMath{\r\n    constructor(rows, cols, element = []) {\r\n        super()\r\n        if(rows instanceof Matrix){\r\n            this.arr=rows.arr;\r\n            this.rows=rows.rows;\r\n            this.cols=rows.cols;\r\n        }\r\n        else {\r\n        let arr = [],\r\n            i,\r\n            j;\r\n        if (arguments[0] instanceof Array) {\r\n            rows = arguments[0].length;\r\n            cols = arguments[0][0].length;\r\n            arr = arguments[0];\r\n        } else {\r\n            for (i = 0; i < rows; i++) {\r\n                arr.push([]);\r\n                arr[i].push(new Array(cols));\r\n                for (j = 0; j < cols; j++) {\r\n                    arr[i][j] = element[i * cols + j];\r\n                    if (element[i * cols + j] == undefined) arr[i][j] = 0;\r\n                }\r\n            }\r\n        }\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n        this.arr = arr;   \r\n    }\r\n    this._maintain();\r\n        //Object.seal(this);\r\n    }\r\n    at(i=0,j=undefined){\r\n        if(i<0)i=this.rows+i;\r\n        if(j==undefined) return this.arr[i];\r\n        if(j<0)j=this.cols+j;\r\n        return this.arr[i][j];\r\n    }\r\n    reshape(newRows, newCols) {\r\n        let check = newRows * newCols === this.rows * this.cols;\r\n        if (check) return new Matrix(newRows, newCols, this.arr.flat(1));\r\n        else console.error(\"Err\");\r\n    }\r\n    static eye(size) {\r\n        let result = new Matrix(size, size);\r\n        for (let i = 0; i < size; i++) for (let j = 0; j < size; j++) i === j ? (result.arr[i][j] = 1) : (result.arr[i][j] = 0);\r\n        return result;\r\n    }\r\n    get clone() {\r\n        return new Matrix(this.rows, this.cols, this.arr.flat(1));\r\n    }\r\n    get size() {\r\n        return this.rows * this.cols;\r\n    } \r\n    get shape() {\r\n        return [this.rows, this.cols];\r\n    }\r\n    get reel() {\r\n        return new Matrix(this.cols, this.rows, this.arr.flat(1).reel);\r\n    }\r\n    get imag() {\r\n        return new Matrix(this.cols, this.rows, this.arr.flat(1).imag);\r\n    }\r\n    _maintain(){\r\n        for(let i=0;i<this.arr.length;i++)Object.assign(this,{[[i]]:this.arr[i]});\r\n        return this;\r\n    }\r\n    get(row = 0, col = 0) {\r\n        if (col == -1) return this.arr[row];\r\n        else if (row == -1) return this.arr.map((n) => n[col]);\r\n        else return this.arr[row][col];\r\n    }\r\n    set(row = 0, col = 0, value) {\r\n        if (col == -1) return (this.arr[row] = value);\r\n        else if (row == -1) {\r\n            for (let i = 0; i < this.cols; i++) {\r\n                this.arr[i][col] = value[i] || 0;\r\n            }\r\n            return this.arr;\r\n        }\r\n        return (this.arr[row][col] = value);\r\n    }\r\n    get isSquare() {\r\n        return this.rows / this.cols === 1;\r\n    }\r\n    get isSym() {\r\n        if (!this.isSquare) return false;\r\n        const T = this.T;\r\n        const M = this.clone;\r\n        return Matrix.sub(M, T).max == 0 && Matrix.sub(M, T).min == 0;\r\n    }\r\n    get isAntiSym() {\r\n        if (!this.isSquare) return false;\r\n        const T = this.T;\r\n        const M = this.clone;\r\n        return Matrix.add(M, T).max == 0 && Matrix.add(M, T).min == 0;\r\n    }\r\n    get isDiag() {\r\n        if (!this.isSquare) return false;\r\n        const T = this.T;\r\n        const M = this.clone;\r\n        const MT = Matrix.mul(M, T);\r\n        const TM = Matrix.dot(T, M);\r\n        return Matrix.sub(MT, TM).max == 0 && Matrix.sub(MT, TM).min == 0;\r\n    }\r\n    get isOrtho() {\r\n        if (!this.isSquare) return false;\r\n        return this.isDiag && (this.det == 1 || this.det == -1);\r\n    }\r\n    get isIdemp() {\r\n        if (!this.isSquare) return false;\r\n        const M = this.clone;\r\n        const MM = Matrix.dot(M, M);\r\n        return Matrix.sub(MM, M).max == 0 && Matrix.sub(MM, M).min == 0;\r\n    }\r\n    get T() {\r\n        let transpose = [];\r\n        for (let i = 0; i < this.arr[0].length; i++) {\r\n            transpose[i] = [];\r\n            for (let j = 0; j < this.arr.length; j++) {\r\n                transpose[i][j] = this.arr[j][i];\r\n            }\r\n        }\r\n        return new Matrix(this.cols, this.rows, transpose.flat(1));\r\n    }\r\n    get det() {\r\n        if (!this.isSquare) return new Error(\"is not square matrix\");\r\n        if (this.rows == 1) return this.arr[0][0];\r\n        function determinat(M) {\r\n            if (M.length == 2) {\r\n                if (M.flat(1).some((n) => n instanceof Matrix)) {\r\n                    console.warn(\"Tensors are not completely supported yet ...\");\r\n                    return;\r\n                }\r\n                return Utils.sub(Utils.mul(M[0][0],M[1][1]),Utils.mul(M[0][1],M[1][0]))\r\n            }\r\n            var answer = 0;\r\n            for (var i = 0; i < M.length; i++) {\r\n                //console.log(M[0][i]);\r\n                /*answer = answer.add(\r\n                    pow(-1, i)\r\n                        .mul(M[0][i])\r\n                        .mul(determinat(deleteRowAndColumn(M, i)))\r\n                );*/\r\n                //const to_be_added=Utils.add(Utils.mul(pow(-1, i),Utils.mul(M[0][i],determinat(deleteRowAndColumn(M, i)))));\r\n                const to_be_added=Utils.add(Utils.mul(pow(-1, i),Utils.mul(M[0][i],determinat(deleteRowAndColumn(M, i)))));\r\n                answer=Utils.add(answer,to_be_added)\r\n            }\r\n            return answer;\r\n        }\r\n        function deleteRowAndColumn(M, index) {\r\n            var temp = [];\r\n            for (let i = 0; i < M.length; i++) temp.push(M[i].slice(0));\r\n            temp.splice(0, 1);\r\n            for (let i = 0; i < temp.length; i++) temp[i].splice(index, 1);\r\n            return temp;\r\n        }\r\n        return determinat(this.arr);\r\n    }\r\n    get inv() {\r\n        if (!this.isSquare) return new Error(\"is not square matrix\");\r\n        if (this.det === 0) return \"determinat = 0 !!!\";\r\n        let A = InverseMatrixe(this.arr);\r\n        return new Matrix(this.rows, this.cols, A.flat(1));\r\n    }\r\n    static zeros(rows, cols) {\r\n        let result = new Matrix(rows, cols);\r\n        for (let i = 0; i < rows; i++) for (var j = 0; j < cols; j++) result.arr[i][j] = 0;\r\n        return result;\r\n    }\r\n    static ones(rows, cols) {\r\n        let result = new Matrix(rows, cols);\r\n        for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) result.arr[i][j] = 1;\r\n        return result;\r\n    }\r\n    static numbers(rows, cols, number) {\r\n        let result = new Matrix(rows, cols);\r\n        for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) result.arr[i][j] = number;\r\n        return result;\r\n    }\r\n    static get rand(){\r\n        return {\r\n            int:(rows, cols, a, b)=>{\r\n                let result = new Matrix(rows, cols);\r\n                for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) result.arr[i][j] = Random.randInt(a, b);\r\n                return result;\r\n            },\r\n            bin:(rows,cols)=>{\r\n                let result = new Matrix(rows, cols);\r\n                for (let i = 0; i < rows; i++) {\r\n                    for (let j = 0; j < cols; j++) result.arr[i][j] = Random.randBin;\r\n                }\r\n                return result;       \r\n            },\r\n            hex:(rows,cols)=>{\r\n                let result = new Matrix(rows, cols);\r\n                for (let i = 0; i < rows; i++) {\r\n                    for (let j = 0; j < cols; j++) result.arr[i][j] = Random.randHex;\r\n                }\r\n                return result;       \r\n            },\r\n            choices:(rows, cols, choices, p)=>{\r\n                let result = new Matrix(rows, cols);\r\n                for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) result.arr[i][j] = Random.choice(choices, p);\r\n                return result\r\n            },\r\n            permutation:(rows,cols,arr)=>{\r\n                //return new Matrix(rows, cols, Random.permutation(...arr))\r\n            }\r\n        }\r\n    }\r\n    static rands(rows, cols, a = 1, b) {\r\n        let result = new Matrix(rows, cols);\r\n        for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) result.arr[i][j] = Random.rand(a, b);\r\n        return result;\r\n    }\r\n    /*static randsInt(rows, cols, a, b) {\r\n    }\r\n    static randsBin(rows, cols) {\r\n    }\r\n    static randsHex(rows, cols) {\r\n    }\r\n    static randsChoices(rows, cols, choices, p) {\r\n    }\r\n    static randPermutation(rows, cols, arr) {\r\n        return new Matrix(rows, cols, Random.permutation(...arr));\r\n    }*/\r\n    /*map(fct) {\r\n        var array = this.arr.flat(1);\r\n        return new Matrix(\r\n            this.rows,\r\n            this.cols,\r\n            array.map((n) => fct(n))\r\n        );\r\n    }\r\n    static map(m, fct) {\r\n        var array = m.arr.flat(1);\r\n        return new Matrix(\r\n            m.rows,\r\n            m.cols,\r\n            array.map((n) => fct(n))\r\n        );\r\n    }*/\r\n    map(Imin, Imax, Fmin, Fmax) {\r\n        return Utils.map(this, Imin, Imax, Fmin, Fmax);\r\n    }\r\n    lerp(min, max) {\r\n        return Utils.lerp(this, min, max);\r\n    }\r\n    norm(min, max) {\r\n        return Utils.norm(this, min, max);\r\n    }\r\n    clamp(min, max) {\r\n        return Utils.clamp(this, min, max);\r\n    }\r\n    static map(matrix, Imin, Imax, Fmin, Fmax) {\r\n        return Utils.map(matrix, Imin, Imax, Fmin, Fmax);\r\n    }\r\n    static lerp(matrix, min, max) {\r\n        return Utils.lerp(matrix, min, max);\r\n    }\r\n    static norm(matrix, min, max) {\r\n        return Utils.norm(matrix, min, max);\r\n    }\r\n    static clamp(m, min, max) {\r\n        return Utils.clamp(matrix, min, max);\r\n    }\r\n    toPrecision(p) {\r\n        for (let i = 0; i < this.cols; i++) for (let j = 0; j < this.rows; j++) this.arr[i][j] = +this.arr[i][j].toPrecision(p);\r\n        return this;\r\n    }\r\n    get toBin() {\r\n        let newArr = this.arr.flat(1).toBin;\r\n        return new Matrix(this.rows, this.cols, newArr);\r\n    }\r\n    get toOct() {\r\n        let newArr = this.arr.flat(1).toOct;\r\n        return new Matrix(this.rows, this.cols, newArr);\r\n    }\r\n    get toHex() {\r\n        let newArr = this.arr.flat(1).toHex;\r\n        return new Matrix(this.rows, this.cols, newArr);\r\n    }\r\n    /*get isOdd() {\r\n        let newArr = this.arr.flat(1).isOdd;\r\n        return new Matrix(this.rows, this.cols, newArr);\r\n    }*/\r\n    max2min() {\r\n        let newArr = this.arr.flat(1).max2min;\r\n        return new Matrix(this.rows, this.cols, newArr);\r\n    }\r\n    min2max() {\r\n        let newArr = this.arr.flat(1).min2max;\r\n        return new Matrix(this.rows, this.cols, newArr);\r\n    }\r\n    sortRows(calback=undefined){\r\n        let newArr=this.arr.map(n=>n.sort(calback)).flat(1);\r\n        return new Matrix(this.rows, this.cols, newArr);           \r\n    }\r\n    sortCols(calback=undefined){\r\n        let m=this.T;\r\n        let newArr=m.arr.map(n=>n.sort(calback)).flat(1);\r\n        return new Matrix(this.rows, this.cols, newArr).T;           \r\n    }\r\n    filterByRows(item){\r\n        var truth=this.arr.map(n=>n.map(m=>+(\"\"+m).includes(item)))\r\n        var mask=truth.map(n=>!!Logic.or(...n))\r\n        var filtredArray=this.arr.filter((n,i)=>mask[i]===true)\r\n        if(filtredArray.length===0)filtredArray.push([])\r\n        console.log(filtredArray)\r\n        return new Matrix(filtredArray)\r\n    }\r\n    filterByCols(item){\r\n        return new Matrix(this.T.arr.filter(n=>n.includes(item)))\r\n    }\r\n    sortAll(calback=undefined){\r\n        let newArr=this.arr.flat(1).sort(calback);\r\n        return new Matrix(this.rows, this.cols, newArr);         \r\n    }\r\n    count(n) {\r\n        return this.arr.flat(1).count(n);\r\n    }\r\n    toBase(n) {\r\n        let newArr = this.arr.flat(1).toBase(n);\r\n        return new Matrix(this.rows, this.cols, newArr);\r\n    }\r\n    #hstack(matrix){\r\n        if (this.rows !== matrix.rows) return;\r\n        let newArr = this.arr;\r\n        for (let i = 0; i < this.rows; i++) for (let j = this.cols; j < this.cols + matrix.cols; j++) newArr[i][j] = matrix.arr[i][j - this.cols];\r\n        this.cols += matrix.cols;\r\n        return new Matrix(this.rows, this.cols, newArr.flat(1));\r\n    }\r\n    hstack(...matrices) {\r\n        const M=[this,...matrices].reduce((a,b)=>a.#hstack(b));\r\n        Object.assign(this,M)\r\n        return this;\r\n    }\r\n    static hstack(matrix,...matrices) {\r\n        return matrix.clone.hstack(...matrices);\r\n    }\r\n    #vstack(matrix) {\r\n        if (this.cols !== matrix.cols) return;\r\n        let newArr = this.arr;\r\n        for (let i = this.rows; i < this.rows + matrix.rows; i++) {\r\n            newArr[i] = [];\r\n            for (let j = 0; j < this.cols; j++) newArr[i][j] = matrix.arr[i - this.rows][j];\r\n        }\r\n        this.rows += matrix.rows;\r\n        return new Matrix(this.rows, this.cols, newArr.flat(1));\r\n    }\r\n    vstack(...matrices) {\r\n        const M=[this,...matrices].reduce((a,b)=>a.#vstack(b));\r\n        Object.assign(this,M)\r\n        return this;\r\n    }\r\n    static vstack(matrix,...matrices) {\r\n        return matrix.clone.vstack(...matrices);\r\n    }\r\n    hqueue(...matrices){\r\n        const M=[this,...matrices].reverse().reduce((a,b)=>a.#hstack(b));\r\n        Object.assign(this,M)\r\n        return this;\r\n    }\r\n    vqueue(...matrices){\r\n        const M=[this,...matrices].reverse().reduce((a,b)=>a.#vstack(b));\r\n        Object.assign(this,M)\r\n        return this;\r\n    }\r\n    static hqueue(matrix,...matrices) {\r\n        return matrix.clone.hqueue(...matrices);\r\n    }\r\n    static vqueue(matrix,...matrices) {\r\n        return matrix.clone.vqueue(...matrices);\r\n    }\r\n    slice(r0=0, c0=0, r1=this.rows-1, c1=this.cols-1) {\r\n        let newRow = r1 - r0,\r\n            newCol = c1 - c0;\r\n        let newArr = new Array(newCol);\r\n        for (let i = 0; i < newRow; i++) {\r\n            newArr[i] = [];\r\n            for (let j = 0; j < newCol; j++) newArr[i][j] = this.arr[i + r0][j + c0];\r\n        }\r\n        return new Matrix(newRow, newCol, newArr.flat(1));\r\n    }\r\n    static slice(m1,r0=0, c0=0, r1=this.rows-1, c1=this.cols-1) {\r\n        return m1.slice(r0, c0, r1, c1);\r\n    }\r\n    getRows(ri, rf = ri + 1) {\r\n        return this.slice(ri, 0, rf, this.cols);\r\n    }\r\n    getCols(ci, cf = ci + 1) {\r\n        return this.slice(0, ci, this.rows, cf);\r\n    }\r\n    static getRows(m, ri, rf = ri + 1) {\r\n        return m.slice(ri, 0, rf, m.cols);\r\n    }\r\n    static getCols(m, ci, cf = ci + 1) {\r\n        return m.slice(0, ci, m.rows, cf);\r\n    }\r\n    add(...matr) {\r\n        for (let k = 0; k < matr.length; k++) {\r\n            if (typeof matr[k] == \"number\"||matr[k] instanceof Math.Complex) matr[k] = Matrix.numbers(this.rows, this.cols, matr[k]);\r\n            for (let i = 0; i < this.rows; i++) for (var j = 0; j < this.cols; j++) this.arr[i][j] = Utils.add(this.arr[i][j],matr[k].arr[i][j]);\r\n        }\r\n        return new Matrix(this.rows, this.cols, this.arr.flat(1));\r\n    }\r\n    sub(...matr) {\r\n        for (let k = 0; k < matr.length; k++) {\r\n            if (typeof matr[k] == \"number\") matr[k] = Matrix.numbers(this.rows, this.cols, matr[k]);\r\n            for (let i = 0; i < this.rows; i++) for (var j = 0; j < this.cols; j++) this.arr[i][j] = Utils.sub(this.arr[i][j],matr[k].arr[i][j]);\r\n        }\r\n        return new Matrix(this.rows, this.cols, this.arr.flat(1));\r\n    }\r\n    static add(m1, ...m2) {\r\n        return m1.clone.add(...m2);\r\n    }\r\n    static sub(m1, ...m2) {\r\n        return m1.clone.sub(...m2);\r\n    }\r\n    mul(...matr) {\r\n        for (let k = 0; k < matr.length; k++) {\r\n            if (typeof matr[k] == \"number\") matr[k] = Matrix.numbers(this.rows, this.cols, matr[k]);\r\n            for (var i = 0; i < this.rows; i++) for (var j = 0; j < this.cols; j++) this.arr[i][j] = Utils.mul(this.arr[i][j],matr[k].arr[i][j]);\r\n        }\r\n        return new Matrix(this.rows, this.cols, this.arr.flat(1));\r\n    }\r\n    div(...matr) {\r\n        for (let k = 0; k < matr.length; k++) {\r\n            if (typeof matr[k] == \"number\") matr[k] = Matrix.numbers(this.rows, this.cols, matr[k]);\r\n            for (let i = 0; i < this.rows; i++) for (var j = 0; j < this.cols; j++) this.arr[i][j] = Utils.div(this.arr[i][j],matr[k].arr[i][j]);\r\n        }\r\n        return new Matrix(this.rows, this.cols, this.arr.flat(1));\r\n    }\r\n    static div(m1, ...m2) {\r\n        return m1.clone.div(...m2);\r\n    }\r\n    static mul(m1, ...m2) {\r\n        return m1.clone.mul(...m2);\r\n    }\r\n    modulo(...matr) {\r\n        for (let k = 0; k < matr.length; k++) {\r\n            if (typeof matr[k] == \"number\") matr[k] = Matrix.numbers(this.rows, this.cols, matr[k]);\r\n            for (let i = 0; i < this.rows; i++) for (var j = 0; j < this.cols; j++)this.arr[i][j]=Utils.modulo(this.arr[i][j],matr[k].arr[i][j]);\r\n        }\r\n        return new Matrix(this.rows, this.cols, this.arr.flat(1));\r\n    }\r\n    static modulo(m1, ...m2) {\r\n        return m1.clone.modulo(...m2);\r\n    }\r\n    dot(matrix) {\r\n        var res = [];\r\n        for (var i = 0; i < this.arr.length; i++) {\r\n            res[i] = [];\r\n            for (var j = 0; j < matrix.arr[0].length; j++) {\r\n                res[i][j] = 0;\r\n                for (var k = 0; k < this.arr[0].length; k++) {\r\n                    res[i][j] = res[i][j].add(this.arr[i][k].mul(matrix.arr[k][j]));\r\n                }\r\n            }\r\n        }\r\n        return new Matrix(this.arr.length, matrix.arr[0].length, res.flat(1));\r\n    }\r\n    static dot(matrix1, matrix2) {\r\n        return matrix1.dot(matrix2);\r\n    }\r\n    pow(n) {\r\n        let a = this.clone,\r\n            p = this.clone;\r\n        for (let i = 0; i < n - 1; i++) p = p.dot(a);\r\n        return p;\r\n    }\r\n    static pow(m, n) {\r\n        return m.clone.pow(n);\r\n    }\r\n    get somme() {\r\n        let S = 0;\r\n        for (let i = 0; i < this.rows; i++) for (let j = 0; j < this.cols; j++) S += this.arr[i][j];\r\n        return S;\r\n    }\r\n    get DoesItContainComplexNumbers() {\r\n        return this.arr.flat(Infinity).some((n) => n instanceof Complex);\r\n    }\r\n    get min() {\r\n        if (this.DoesItContainComplexNumbers) console.error(\"Complex numbers are not comparable\");\r\n        let minRow = [];\r\n        for (let i = 0; i < this.rows; i++) minRow.push(min(...this.arr[i]));\r\n        return min(...minRow);\r\n    }\r\n    get max() {\r\n        if (this.DoesItContainComplexNumbers) console.error(\"Complex numbers are not comparable\");\r\n        let maxRow = [];\r\n        for (let i = 0; i < this.rows; i++) maxRow.push(max(...this.arr[i]));\r\n        return max(...maxRow);\r\n    }\r\n    get minRows() {\r\n        if (this.DoesItContainComplexNumbers) console.error(\"Complex numbers are not comparable\");\r\n        let minRow = [];\r\n        for (let i = 0; i < this.rows; i++) minRow.push(min(...this.arr[i]));\r\n        return minRow;\r\n    }\r\n    get maxRows() {\r\n        if (this.DoesItContainComplexNumbers) console.error(\"Complex numbers are not comparable\");\r\n        let maxRow = [];\r\n        for (let i = 0; i < this.rows; i++) maxRow.push(max(...this.arr[i]));\r\n        return maxRow;\r\n    }\r\n    get minCols() {\r\n        if (this.DoesItContainComplexNumbers) console.error(\"Complex numbers are not comparable\");\r\n        return this.T.minRows;\r\n    }\r\n    get maxCols() {\r\n        if (this.DoesItContainComplexNumbers) console.error(\"Complex numbers are not comparable\");\r\n        return this.T.maxRows;\r\n    }\r\n    static fromVector(v) {\r\n        return new Matrix(v.length, 1, v);\r\n    }\r\n    get toArray() {\r\n        let arr = [];\r\n        for (let i = 0; i < this.rows; i++) {\r\n            for (let j = 0; j < this.cols; j++) {\r\n                arr.push(this.arr[i][j]);\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    get print() {\r\n        //\"pretty print\" the matrix\r\n        let fstring = \"[\";\r\n        for (let i = 0; i < this.arr.length; i++) {\r\n            fstring += (i != 0 ? \" \" : \"\") + ` [${this.arr[i].map((n) => \" \" + n.toString() + \" \")}],\\n`;\r\n        }\r\n        console.log(fstring.substring(0, fstring.length - 2) + \" ]\");\r\n        document.write(fstring.substring(0, fstring.length - 2) + \" ]\");\r\n    }\r\n    get table() {\r\n        console.table(this.arr);\r\n    }\r\n    get serialize() {\r\n        return JSON.stringify(this);\r\n    }\r\n    static deserialize(data) {\r\n        if (typeof data == \"string\") {\r\n            data = JSON.parse(data);\r\n        }\r\n        let matrix = new Matrix(data.rows, data.cols);\r\n        matrix.arr = data.arr;\r\n        return matrix;\r\n    }\r\n    toTable() {\r\n        var table = new DocumentFragment();\r\n        var Tr = new Array(this.rows).fill(null).map(() => document.createElement(\"tr\"));\r\n        var Td = this.arr.map((n) => n.map(() => document.createElement(\"td\")));\r\n        for (let i = 0; i < Td.length; i++) {\r\n            for (let j = 0; j < Td[0].length; j++) {\r\n                Td[i][j].innerHTML = this.arr[i][j];\r\n                Tr[i].appendChild(Td[i][j]);\r\n            }\r\n        }\r\n        Tr.map((n) => table.appendChild(n));\r\n        return table;\r\n    }\r\n    toGrid(element, style = {}) {\r\n        let a = Grid();\r\n        a.append(\r\n            ...this.map(element)\r\n                .arr.flat(1)\r\n                .map((n) => n.style(style))\r\n        );\r\n        a.Columns(this.cols);\r\n        return a;\r\n    }\r\n    sortTable(n=0,{type=\"num\",order=\"asc\"}={}) {\r\n        var obj=this.T.arr.map(n=>n.map((n,i)=>Object.assign({},{x:n,y:i})));\r\n        var newObj=this.T.arr.map(n=>n.map((n,i)=>Object.assign({},{x:n,y:i})));\r\n        if(type===\"num\"){\r\n            if(order===\"asc\")obj[n].sort((a,b)=>a.x-b.x);\r\n            else if(order===\"desc\")obj[n].sort((a,b)=>b.x-a.x);\r\n            else if(order===\"toggle\"){\r\n               // console.log(obj[n][0])\r\n                //console.log(obj[n][1])\r\n                if(obj[n][0].x>obj[n][1].x)obj[n].sort((a,b)=>b.x-a.x);\r\n                else obj[n].sort((a,b)=>a.x-b.x);\r\n            }\r\n        }\r\n        else if(type===\"alpha\"){\r\n            if(order===\"asc\")obj[n].sort((a,b)=>(\"\"+a.x).localeCompare(\"\"+b.x));\r\n            else if(order===\"desc\")obj[n].sort((a,b)=>(\"\"+b.x).localeCompare(\"\"+a.x));            \r\n        }\r\n        //var order=obj[n].map(n=>n.y);\r\n        order=obj[n].map(n=>n.y);\r\n        for(let i=0;i<obj.length;i++){\r\n            if(i!==n)obj[i].map((n,j)=>n.y=order[j]);\r\n        }\r\n        for(let i=0;i<obj.length;i++){\r\n            if(i!==n)newObj[i].map((n,j)=>n.x=obj[i][order[j]].x)\r\n        }\r\n        newObj[n]=obj[n];\r\n        var newArr=newObj.map(n=>n.map(m=>m.x));\r\n        return new Matrix(newArr).T;\r\n    }\r\n}\r\n\r\nfunction InverseMatrixe(M) {\r\n    if (M.length !== M[0].length) {\r\n        return;\r\n    }\r\n    var i = 0,\r\n        ii = 0,\r\n        j = 0,\r\n        dim = M.length,\r\n        e = 0;\r\n        //t = 0;\r\n    var I = [],\r\n        C = [];\r\n    for (i = 0; i < dim; i += 1) {\r\n        I[I.length] = [];\r\n        C[C.length] = [];\r\n        for (j = 0; j < dim; j += 1) {\r\n            if (i == j) {\r\n                I[i][j] = 1;\r\n            } else {\r\n                I[i][j] = 0;\r\n            }\r\n            C[i][j] = M[i][j];\r\n        }\r\n    }\r\n    for (i = 0; i < dim; i += 1) {\r\n        e = C[i][i];\r\n        if (e == 0) {\r\n            for (ii = i + 1; ii < dim; ii += 1) {\r\n                if (C[ii][i] != 0) {\r\n                    for (j = 0; j < dim; j++) {\r\n                        e = C[i][j];\r\n                        C[i][j] = C[ii][j];\r\n                        C[ii][j] = e;\r\n                        e = I[i][j];\r\n                        I[i][j] = I[ii][j];\r\n                        I[ii][j] = e;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            e = C[i][i];\r\n            if (e == 0) {\r\n                return;\r\n            }\r\n        }\r\n        for (j = 0; j < dim; j++) {\r\n            C[i][j] = C[i][j] / e;\r\n            I[i][j] = I[i][j] / e;\r\n        }\r\n        for (ii = 0; ii < dim; ii++) {\r\n            if (ii == i) {\r\n                continue;\r\n            }\r\n            e = C[ii][i];\r\n            for (j = 0; j < dim; j++) {\r\n                C[ii][j] -= e * C[i][j];\r\n                I[ii][j] -= e * I[i][j];\r\n            }\r\n        }\r\n    }\r\n    return I;\r\n}\r\n\r\nclass LinearSystem {\r\n    static resolve(A, B) {\r\n        return A.inv\r\n            .dot(Matrix.fromVector(B))\r\n            .arr.flat(1)\r\n            .map((n) => +n.toFixed(10));\r\n    }\r\n}\r\nvar matrix=(r, c, element)=>new Matrix(r, c, element);\r\nvar matrix2=(...element)=>new Matrix(2, 2, element);\r\nvar matrix3=(...element)=>new Matrix(3, 3, element);\r\nvar matrix4=(...element)=>new Matrix(4, 4, element);\r\nexport{Matrix,LinearSystem,matrix,matrix2,matrix3,matrix4}",
  "Math_Matrix_index_js_stats_length": 24777,
  "Math_Matrix_index_js_stats_size": 24.1962890625,
  "Math_Matrix_index_js_stats_lines": 692,
  "Math_Matrix_index_js_metadata_permissions": 33206,
  "Math_Numeric_index_js_content": "",
  "Math_Numeric_index_js_stats_length": 0,
  "Math_Numeric_index_js_stats_size": 0,
  "Math_Numeric_index_js_stats_lines": 1,
  "Math_Numeric_index_js_metadata_permissions": 33206,
  "Math_Random_index_js_content": "\r\nimport{Complex}from\"../Complex/index.js\"\r\nimport { Utils } from \"../Utils/index.js\";\r\nimport{Base}from\"../Discret/index.js\"\r\n\r\nclass Random {\r\n    static rand(a = 1, b) {\r\n        return b ? Math.random() * (b - a) + a : a * Math.random();\r\n    }\r\n    static randInt(a, b) {\r\n        return Math.floor(Random.rand(a, b));\r\n    }\r\n    static get randBin() {\r\n        return Random.randInt(2);\r\n    }\r\n    static get randOct() {\r\n        return Random.randInt(8);\r\n    }\r\n    static get randHex() {\r\n        return Random.randInt(16);\r\n    }\r\n    static choice(choices = [1, 2, 3], p = new Array(choices.length).fill(1 / choices.length)) {\r\n        let newchoice = new Array(100);\r\n        p=Utils.accum(...p).map(n=>n*100)\r\n        newchoice.fill(choices[0], 0, p[0]);\r\n        for (let i = 1; i < choices.length; i++) newchoice.fill(choices[i], p[i - 1], p[i]);\r\n        return newchoice[Random.randInt(newchoice.length - 1)];\r\n    }\r\n    static shuffle(arr){\r\n        return arr.sort(()=>0.5-Math.random())\r\n    }\r\n    static rands(n, a, b) {\r\n        return new Array(n).fill(0).map(() => Random.rand(a, b));\r\n    }\r\n    static randsInt(n, a, b) {\r\n        return new Array(n).fill(0).map(() => Random.randInt(a, b));\r\n    }\r\n    static randsBin(n) {\r\n        return new Array(n).fill(0).map(() => Random.randInt(2));\r\n    }\r\n    static randsOct(n) {\r\n        return new Array(n).fill(0).map(() => Random.randInt(8));\r\n    }\r\n    static randsHex(n) {\r\n        return new Array(n).fill(0).map(() => Random.randInt(16));\r\n    }\r\n    static choices(n, choices, p) {\r\n        return new Array(n).fill(0).map(() => Random.choice(choices, p));\r\n    }\r\n    static permutation(...arr) {\r\n        return arr.permS[Random.randInt(arr.length)];\r\n    }\r\n    static get randomColor() {\r\n        return \"#\" + Base.dec2hex(Random.rand(16777216)).padStart(6,0);\r\n    }\r\n    static randComplex(a = 0, b = 1) {\r\n        return new Complex(...Random.rands(2, a, b));\r\n    }\r\n    static randIntComplex(a = 0, b = 1) {\r\n        return new Complex(...Random.randsInt(2, a, b));\r\n    }\r\n    static get randBinComplex() {\r\n        return new Complex(...Random.randsBin(2));\r\n    }\r\n    static get randOctComplex() {\r\n        return new Complex(...Random.randsOct(2));\r\n    }\r\n    static get randHexComplex() {\r\n        return new Complex(...Random.randsOct(2));\r\n    }\r\n    static randsComplex(n, a = 0, b = 1) {\r\n        return new Array(n).fill(0).map(() => Random.randComplex(a, b));\r\n    }\r\n    static randsIntComplex(n, a = 0, b = 1) {\r\n        return new Array(n).fill(0).map(() => Random.randIntComplex(a, b));\r\n    }\r\n    static randsBinComplex(n) {\r\n        return new Array(n).fill(0).map(() => Random.randBinComplex);\r\n    }\r\n    static randsOctComplex(n) {\r\n        return new Array(n).fill(0).map(() => Random.randOctComplex);\r\n    }\r\n    static randsHexComplex(n) {\r\n        return new Array(n).fill(0).map(() => Random.randHexComplex);\r\n    }\r\n}\r\nexport{Random}",
  "Math_Random_index_js_stats_length": 2956,
  "Math_Random_index_js_stats_size": 2.88671875,
  "Math_Random_index_js_stats_lines": 87,
  "Math_Random_index_js_metadata_permissions": 33206,
  "Math_Signal_index_js_content": "\r\nvar Signal={\r\n    _map(func){\r\n\r\n    },\r\n    linspace(){\r\n\r\n    },\r\n    logspace(){\r\n\r\n    },\r\n    arange(){\r\n\r\n    },\r\n    echelon(t,t0=0){\r\n        if(typeof t===\"number\")return +(t>=t0);\r\n    },\r\n    rampe(t,t0=0){\r\n        if(typeof t===\"number\")return (t>=t0)?t-t0:0;\r\n    },\r\n    sign(t,t0=0){\r\n        if(typeof t===\"number\")return Math.sign(t-t0);\r\n    },\r\n    rect(t,T,t0=0){\r\n        if(typeof t===\"number\")return this.echelon(t,t0-T/2)-(this.echelon(t,t0+T/2));\r\n    },\r\n    tri(t,T,t0){\r\n        if(typeof t===\"number\"){\r\n            if(Math.abs(t)>T/2)return 0;\r\n            else if(t<t0)return this.rampe(t,t0)\r\n            else return -this.rampe(t,t0)\r\n        }\r\n    },\r\n    dirac(){\r\n\r\n    },\r\n    lorentz(t,t0=0){\r\n        if(typeof t===\"number\")return 1/(1+(t-t0)**2);\r\n    },\r\n    sinc(){\r\n\r\n    },\r\n    square(){\r\n\r\n    },\r\n    sawtooth(){\r\n\r\n    }\r\n    \r\n}\r\nexport{Signal}",
  "Math_Signal_index_js_stats_length": 897,
  "Math_Signal_index_js_stats_size": 0.8759765625,
  "Math_Signal_index_js_stats_lines": 51,
  "Math_Signal_index_js_metadata_permissions": 33206,
  "Math_Utils_index_js_content": "\r\n// Utils\r\n\r\nimport{floor,sqrtn,pow,abs,ln}from \"../Functions/index.js\"\r\nimport{Matrix}from \"../Matrix/index.js\"\r\nimport{complex,Complex}from\"../Complex/index.js\"\r\nimport{PI,E} from \"../const.js\";\r\n//import ZMath from \"./index.js\"  \r\nclass Utils {\r\n    static zeros(num,n){\r\n        return new Array(n).fill(0);\r\n    }\r\n    static ones(num,n){\r\n        return new Array(n).fill(1);\r\n    }\r\n    static numbers(num,n){\r\n        return new Array(n).fill(num);\r\n    }\r\n    static #add(a,b){\r\n        if(typeof(a)===\"number\"){\r\n            if (typeof b == \"number\") return a + b;\r\n            else if (b instanceof Complex)return complex(a + b.a, b.b);\r\n            else if (b instanceof Matrix) return Matrix.numbers(b.rows, b.cols, a).add(b);\r\n            else if (b instanceof Array)return b.map(n=>Utils.add(n,a));                 \r\n        }\r\n        else if(a instanceof Complex||a instanceof Matrix){\r\n            if(b instanceof Array)return b.map(n=>a.clone.add(n));\r\n            return a.clone.add(b);\r\n        }\r\n        else if(a instanceof Array){\r\n            if(b instanceof Array){\r\n\r\n            }\r\n            else {\r\n                return a.map(n=>Utils.add(n,b));\r\n            }\r\n        }\r\n    }\r\n    static #sub(a,b){\r\n        if(typeof(a)===\"number\"){\r\n            if (typeof b == \"number\") return a - b;\r\n            else if (b instanceof Complex)return complex(a - b.a, -b.b);\r\n            else if (b instanceof Matrix) return Matrix.numbers(b.rows, b.cols, a).sub(b);\r\n            else if (b instanceof Array)return b.map(n=>Utils.sub(n,a));                 \r\n        }\r\n        else if(a instanceof Complex||a instanceof Matrix){\r\n            if(b instanceof Array)return b.map(n=>a.clone.sub(n));\r\n            return a.clone.sub(b);\r\n        }\r\n        else if(a instanceof Array){\r\n            if(b instanceof Array){\r\n\r\n            }\r\n            else {\r\n                return a.map(n=>Utils.add(n,b));\r\n            }\r\n        }\r\n    }\r\n    static #mul(a,b){\r\n        if(typeof(a)===\"number\"){\r\n        if (typeof b == \"number\") return a * b;\r\n            else if (b instanceof Complex)return complex(a * b.a,a * b.b);\r\n            else if (b instanceof Matrix) return Matrix.numbers(b.rows, b.cols, a).mul(b);\r\n            else if (b instanceof Array)return b.map(n=>Utils.mul(a,n)); \r\n        }\r\n        else if(a instanceof Complex||a instanceof Matrix){\r\n            if(b instanceof Array)return b.map(n=>a.clone.mul(n));\r\n            return a.clone.mul(b);\r\n        }\r\n        else if(a instanceof Array){\r\n            if(b instanceof Array){\r\n\r\n            }\r\n            else {\r\n                return a.map(n=>Utils.mul(n,b));\r\n            }\r\n        }\r\n    }\r\n    static #div(a,b){\r\n        if(typeof(a)===\"number\"){\r\n        if (typeof b == \"number\") return a / b;\r\n            else if (b instanceof Complex)return complex(a / b.a,a / b.b);\r\n            else if (b instanceof Matrix) return Matrix.numbers(b.rows, b.cols, a).div(b);\r\n            else if (b instanceof Array)return b.map(n=>Utils.div(a,n));\r\n        }\r\n        else if(a instanceof Complex||a instanceof Matrix){\r\n            if(b instanceof Array)return b.map(n=>a.clone.div(n));\r\n            return a.clone.div(b);\r\n        }\r\n        else if(a instanceof Array){\r\n            if(b instanceof Array){\r\n\r\n            }\r\n            else {\r\n                return a.map(n=>Utils.add(n,b));\r\n            }\r\n        }\r\n    }\r\n    static #modulo(a,b){\r\n        if(typeof(a)===\"number\"){\r\n            if (typeof b == \"number\") return a % b;\r\n                else if (b instanceof Complex)return complex(a % b.a,a % b.b);\r\n                else if (b instanceof Matrix) return Matrix.numbers(b.rows, b.cols, a).modulo(b);\r\n                else if (b instanceof Array)return b.map(n=>Utils.div(a,n));\r\n            }\r\n            else if(a instanceof Complex||a instanceof Matrix){\r\n                if(b instanceof Array)return b.map(n=>a.clone.div(n));\r\n                return a.clone.div(b);\r\n            }\r\n            else if(a instanceof Array){\r\n                if(b instanceof Array){\r\n    \r\n                }\r\n                else {\r\n                    return a.map(n=>Utils.add(n,b));\r\n                }\r\n            }\r\n    }\r\n    static add(a,...b){\r\n        var res=a;\r\n        for(let i=0;i<b.length;i++)res=Utils.#add(res,b[i])\r\n        return res;\r\n    }\r\n    static sub(a,...b){\r\n        var res=a;\r\n        for(let i=0;i<b.length;i++)res=Utils.#sub(res,b[i])\r\n        return res;\r\n    }\r\n    static mul(a,...b){\r\n        var res=a;\r\n        for(let i=0;i<b.length;i++)res=Utils.#mul(res,b[i])\r\n        return res;\r\n    }\r\n    static div(a,...b){\r\n        var res=a;\r\n        for(let i=0;i<b.length;i++)res=Utils.#div(res,b[i])\r\n        return res;\r\n    }\r\n    static modulo(a,...b){\r\n        var res=a;\r\n        for(let i=0;i<b.length;i++)res=Utils.#modulo(res,b[i])\r\n        return res;\r\n    }\r\n    static sum(...x) {\r\n        let s = x[0];\r\n        for (let i = 1; i < x.length; i++) s += x[i];\r\n        return s;\r\n    }\r\n    static prod(...x) {\r\n        let p = x[0];\r\n        for (let i = 1; i < x.length; i++) p *= x[i];\r\n        return p;\r\n    }\r\n    static deg2rad(x) {\r\n        if (typeof x === \"number\") return (x * PI) / 180;\r\n        else if (x instanceof Matrix) return new Matrix(x.rows, x.cols, Utils.deg2rad(x.arr.flat(1)));\r\n        else if (x instanceof Complex) return new Complex(Utils.deg2rad(x.a), Utils.deg2rad(x.b));\r\n        else if (x instanceof Array) {\r\n            if (x.every((n) => typeof (n === \"number\"))) {\r\n                return x.map((n) => Utils.deg2rad(n));\r\n            } else {\r\n                let y = new Array(x.length);\r\n                for (let i = 0; i < x.length; i++) {\r\n                    y[i] = this.deg2rad(x[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static rad2deg(x) {\r\n        if (typeof x === \"number\") return (x / PI) * 180;\r\n        else if (x instanceof Matrix) return new Matrix(x.rows, x.cols, Utils.rad2deg(x.arr.flat(1)));\r\n        else if (x instanceof Complex) return new Complex(Utils.rad2deg(x.a), Utils.rad2deg(x.b));\r\n        else if (x instanceof Array) {\r\n            if (x.every((n) => typeof (n === \"number\"))) {\r\n                return x.map((n) => Utils.rad2deg(n));\r\n            } else {\r\n                let y = new Array(x.length);\r\n                for (let i = 0; i < x.length; i++) {\r\n                    y[i] = this.rad2deg(x[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static pgcd(n1, n2) {\r\n        let i,\r\n            pgcd = 1;\r\n        if (n1 == floor(n1) && n2 == floor(n2)) {\r\n            for (i = 2; i <= n1 && i <= n2; ++i) {\r\n                if (n1 % i == 0 && n2 % i == 0) pgcd = i;\r\n            }\r\n            return pgcd;\r\n        } else console.log(\"error\");\r\n    }\r\n    static ppcm(n1, n2) {\r\n        let ppcm;\r\n        if (n1 == floor(n1) && n2 == floor(n2)) {\r\n            ppcm = n1 > n2 ? n1 : n2;\r\n            while (true) {\r\n                if (ppcm % n1 == 0 && ppcm % n2 == 0) break;\r\n                ++ppcm;\r\n            }\r\n            return ppcm;\r\n        } else console.log(\"error\");\r\n    }\r\n    static linspace(a,b,n=abs(b-a)+1,endpoint=true) {\r\n        if(a instanceof Complex||b instanceof Complex){\r\n            a=complex(a);\r\n            b=complex(b);\r\n            n=n||Math.abs(b.a-a.a)+1;\r\n            const X=this.linspace(a.a,b.a,n,endpoint);\r\n            const Y=this.linspace(a.b,b.b,n,endpoint);\r\n            let Z=new Array(n).fill(null);\r\n            Z=Z.map((n,i)=>complex(X[i],Y[i]));\r\n            return Z;\r\n        }\r\n        else if(a instanceof Array){\r\n            let Y=[]\r\n            for(let i=0;i<a.length;i++){\r\n                n=n||abs(b[i]-a[i])+1\r\n                Y[i]=this.linspace(a[i],b[i],n,endpoint);\r\n            }\r\n            return Y;\r\n        }\r\n        const [high,low]=[a,b].sort((a,b)=>b-a);\r\n        if (floor(n) !== n) return;\r\n        var arr = [];\r\n        let step = (high - low) / (n - 1);\r\n        if(!endpoint)step = (high - low) / n;\r\n        for (var i = 0; i < n; i++) {\r\n            arr.push(low+step*i);\r\n        }\r\n        return a<b?arr:arr.reverse();\r\n    }\r\n    static logspace(a,b,n=b-a+1,base=E,endpoint=true){\r\n        if(a instanceof Complex||b instanceof Complex){\r\n            a=complex(a);\r\n            b=complex(b);\r\n            n=n??abs(b.a-a.a)\r\n            const X=this.linspace(a.a,b.a,n,base,endpoint);\r\n            const Y=this.linspace(a.b,b.b,n,base,endpoint);\r\n            const Z=new Array(X.length).fill(0)\r\n            const ZZ=Z.map((n,i) => pow(base,complex(X[i],Y[i])));\r\n            return ZZ;\r\n        }\r\n        const start=base**min(a,b);\r\n        const stop=base**max(a,b);\r\n        const y = Utils.linspace(ln(start) / ln(base), ln(stop) / ln(base), n, endpoint);\r\n        const result=y.map(n => pow(base, n));\r\n        return a<b?result:result.reverse();\r\n    }\r\n    static geomspace(a,b,n=abs(b-a)+1){\r\n        var [high,low]=[a,b].sort((a,b)=>b-a);\r\n        var step=sqrtn(high,n-low);\r\n        var arr=[low]\r\n        for(let i=1;i<n;i++)arr[i]=arr[i-1]*step;\r\n        arr=arr.map(n=>+n.toFixed(8))\r\n        return a<b?arr:arr.reverse()\r\n    }\r\n    static arange(a, b, pas) {\r\n        let tab = [];\r\n        for (let i = a; i < b; i += pas) tab.push((i * 10) / 10);\r\n        return tab;\r\n    }\r\n    static norm(value, min, max) {\r\n        if (typeof value === \"number\") return min !== max ? (value - min) / (max - min) : 0;\r\n        else if (value instanceof Matrix) return new Matrix(value.rows, value.cols, Utils.norm(value.arr.flat(1), min, max));\r\n        else if (value instanceof Complex) return new Complex(Utils.norm(value.a, min, max), Utils.norm(value.b, min, max));\r\n        else if (value instanceof Array) {\r\n            if (value.every((n) => typeof (n === \"number\"))) {\r\n                return value.map((n) => Utils.norm(n, min, max));\r\n            } else {\r\n                let y = new Array(value.length);\r\n                for (let i = 0; i < value.length; i++) {\r\n                    y[i] = this.norm(value[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static lerp(value, min, max) {\r\n        if (typeof value === \"number\") return (max - min) * value + min;\r\n        else if (value instanceof Matrix) return new Matrix(value.rows, value.cols, Utils.lerp(value.arr.flat(1), min, max));\r\n        else if (value instanceof Complex) return new Complex(Utils.lerp(value.a, min, max), Utils.lerp(value.b, min, max));\r\n        else if (value instanceof Array) {\r\n            if (value.every((n) => typeof (n === \"number\"))) {\r\n                return value.map((n) => Utils.lerp(n, min, max));\r\n            } else {\r\n                let y = new Array(value.length);\r\n                for (let i = 0; i < value.length; i++) {\r\n                    y[i] = Utils.lerp(value[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static map(value, a, b, c, d) {\r\n        if (typeof value === \"number\") return Utils.lerp(Utils.norm(value, a, b), c, d);\r\n        else if (value instanceof Matrix) return new Matrix(value.rows, value.cols, Utils.map(value.arr.flat(1), a, b, c, d));\r\n        else if (value instanceof Complex) return new Complex(Utils.map(value.a, b, c, d), Utils.map(value.b, a, b, c, d));\r\n        else if (value instanceof Array) {\r\n            if (value.every((n) => typeof (n === \"number\"))) {\r\n                return value.map((n) => Utils.map(n, a, b, c, d));\r\n            } else {\r\n                let y = new Array(value.length);\r\n                for (let i = 0; i < value.length; i++) {\r\n                    y[i] = Utils.map(value[i], a, b, c, d);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static clamp(value, min, max) {\r\n        if (typeof value === \"number\") return min(max(value, min), max);\r\n        else if (value instanceof Matrix) return new Matrix(value.rows, value.cols, Utils.clamp(value.arr.flat(1), min, max));\r\n        else if (value instanceof Complex) return new Complex(Utils.clamp(value.a, min, max), Utils.clamp(value.b, min, max));\r\n        else if (value instanceof Array) {\r\n            if (value.every((n) => typeof (n === \"number\"))) {\r\n                return value.map((n) => Utils.clamp(n, min, max));\r\n            } else {\r\n                let y = new Array(value.length);\r\n                for (let i = 0; i < value.length; i++) {\r\n                    y[i] = Utils.clamp(value[i], min, max);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static aproximatelyEqual(a,b,Epsilon=0.0001){\r\n        return abs(a-b)<Epsilon;\r\n    }\r\n    static cartesianProduct(a, b){\r\n        return a.reduce((p, x) => [...p, ...b.map((y) => [x, y])], []);\r\n    }\r\n    static accum(...arr){\r\n        let acc = arr.reduce((x, y) => [...x, x[x.length - 1] + y], [0]);\r\n            acc.shift();\r\n            return acc;\r\n    }\r\n}\r\nvar {zeros,ones,numbers,sum,prod,add,mul,div,sub,modulo,rad2deg,deg2rad,arange,linspace,logspace,norm,lerp,map,clamp,pgcd,ppcm,aproximatelyEqual,cartesianProduct}=Utils\r\nexport {\r\n    Utils,\r\n    zeros,\r\n    ones,\r\n    numbers,\r\n    sum,\r\n    prod,\r\n    add,\r\n    mul,\r\n    sub,\r\n    div,\r\n    modulo,\r\n    rad2deg,\r\n    deg2rad,\r\n    arange,\r\n    linspace,\r\n    logspace,\r\n    norm,\r\n    lerp,\r\n    map,\r\n    clamp,\r\n    pgcd,\r\n    ppcm,\r\n    aproximatelyEqual,\r\n    cartesianProduct,\r\n  };\r\n ",
  "Math_Utils_index_js_stats_length": 13353,
  "Math_Utils_index_js_stats_size": 13.0400390625,
  "Math_Utils_index_js_stats_lines": 363,
  "Math_Utils_index_js_metadata_permissions": 33206,
  "Math_absract_js_content": "export default class AbstractZikoMath {}",
  "Math_absract_js_stats_length": 40,
  "Math_absract_js_stats_size": 0.0390625,
  "Math_absract_js_stats_lines": 1,
  "Math_absract_js_metadata_permissions": 33206,
  "Math_const_js_content": "const { PI, E } = Math;\r\nconst EPSILON=Number.EPSILON\r\nexport{PI,E,EPSILON}",
  "Math_const_js_stats_length": 75,
  "Math_const_js_stats_size": 0.0732421875,
  "Math_const_js_stats_lines": 3,
  "Math_const_js_metadata_permissions": 33206,
  "Math_index_js_content": "//import Ziko from \"../index.js\"\r\nimport {PI,E,EPSILON} from \"./const.js\"\r\nimport { Signal } from \"./Signal/index.js\";\r\nimport{\r\n    cos,\r\n    sin,\r\n    tan,\r\n    cot,\r\n    sec,\r\n    csc,\r\n    abs,\r\n    sqrt,\r\n    pow,\r\n    sqrtn,\r\n    e,\r\n    ln,\r\n    acos,\r\n    asin,\r\n    atan,\r\n    acot,\r\n    cosh,\r\n    sinh,\r\n    tanh,\r\n    coth,\r\n    acosh,\r\n    asinh,\r\n    atanh,\r\n    min,\r\n    max,\r\n    sign,\r\n    floor,\r\n    ceil,\r\n    round,\r\n    fact,\r\n    hypot,\r\n    sig,\r\n    atan2,\r\n  } from \"./Functions/index.js\";\r\nimport {Random} from \"./Random/index.js\";\r\n//import { Derivation } from \"./Numeric/index.js\";\r\nimport {complex,Complex} from \"./Complex/index.js\";\r\nimport{Matrix,LinearSystem,matrix,matrix2,matrix3,matrix4}from \"./Matrix/index.js\"\r\nimport Discret from \"./Discret/index.js\";\r\nimport {Logic,Base,Permutation,Combinaison,PowerSet,subset} from \"./Discret/index.js\";\r\nimport {\r\n    Utils,\r\n    zeros,\r\n    ones,\r\n    numbers,\r\n    sum,\r\n    prod,\r\n    add,\r\n    mul,\r\n    div,\r\n    sub,\r\n    modulo,\r\n    rad2deg,\r\n    deg2rad,\r\n    arange,\r\n    linspace,\r\n    norm,\r\n    lerp,\r\n    map,\r\n    clamp,\r\n    pgcd,\r\n    ppcm,\r\n    aproximatelyEqual,\r\n    cartesianProduct\r\n  }from \"./Utils/index.js\"\r\nconst Math={\r\n    PI,\r\n    E,\r\n    EPSILON,\r\n    Random,\r\n    complex,\r\n    Complex,\r\n    Matrix,\r\n    LinearSystem,\r\n    matrix,\r\n    matrix2,\r\n    matrix3,\r\n    matrix4,\r\n    cos,\r\n    sin,\r\n    tan,\r\n    sec,\r\n    csc,\r\n    cot,\r\n    abs,\r\n    sqrt,\r\n    pow,\r\n    sqrtn,\r\n    e,\r\n    ln,\r\n    acos,\r\n    asin,\r\n    atan,\r\n    acot,\r\n    cosh,\r\n    sinh,\r\n    tanh,\r\n    coth,\r\n    acosh,\r\n    asinh,\r\n    atanh,\r\n    min,\r\n    max,\r\n    sign,\r\n    floor,\r\n    ceil,\r\n    round,\r\n    fact,\r\n    hypot,\r\n    sig,\r\n    atan2,\r\n   // Derivation,\r\n    Utils,\r\n    numbers,\r\n    zeros,\r\n    ones,\r\n    sum,\r\n    prod,\r\n    add,\r\n    mul,\r\n    div,\r\n    sub,\r\n    modulo,\r\n    rad2deg,\r\n    deg2rad,\r\n    arange,\r\n    linspace,\r\n    norm,\r\n    lerp,\r\n    map,\r\n    clamp,\r\n    pgcd,\r\n    ppcm,\r\n    aproximatelyEqual,\r\n    cartesianProduct,\r\n    Discret,\r\n    Logic,\r\n    Base,\r\n    Permutation,\r\n    Combinaison,\r\n    PowerSet,\r\n    subset,\r\n    Signal,\r\n    /*ExtractAll:function(){\r\n            for (let i = 0; i < Object.keys(Ziko.Math).length; i++) {\r\n                globalThis[Object.keys(Ziko.Math)[i]] = Object.values(Ziko.Math)[i];\r\n        }\r\n        return this;\r\n    },\r\n    RemoveAll:function(){\r\n            for (let i = 0; i < Object.keys(Ziko.Math).length; i++) delete globalThis[Object.keys(Ziko.Math)[i]];   \r\n        return this;\r\n    }*/\r\n}\r\nexport {Math};\r\n\r\n",
  "Math_index_js_stats_length": 2588,
  "Math_index_js_stats_size": 2.52734375,
  "Math_index_js_stats_lines": 161,
  "Math_index_js_metadata_permissions": 33206,
  "String_index_js_content": "\r\n",
  "String_index_js_stats_length": 2,
  "String_index_js_stats_size": 0.001953125,
  "String_index_js_stats_lines": 2,
  "String_index_js_metadata_permissions": 33206,
  "Time_index_js_content": "\r\n",
  "Time_index_js_stats_length": 2,
  "Time_index_js_stats_size": 0.001953125,
  "Time_index_js_stats_lines": 2,
  "Time_index_js_metadata_permissions": 33206,
  "UI_Embaded_index_js_content": "\r\n",
  "UI_Embaded_index_js_stats_length": 2,
  "UI_Embaded_index_js_stats_size": 0.001953125,
  "UI_Embaded_index_js_stats_lines": 2,
  "UI_Embaded_index_js_metadata_permissions": 33206,
  "UI_Flex_flex_js_content": "import ZikoUIElement from \"../Setup.js\"\r\nfunction set_vertical(direction){\r\n    direction == 1\r\n      ? this.style({ flexDirection: \"column\" })\r\n      : direction == -1 && this.style({ flexDirection: \"column-reverse\" });\r\n    return this;\r\n  }\r\nfunction set_horizontal(direction){\r\n  direction == 1\r\n      ? this.style({ flexDirection: \"row\" })\r\n      : direction == -1 && this.style({ flexDirection: \"row-reverse\" });\r\n    return this;\r\n}\r\n\r\nfunction map_pos_x(align){\r\n  let pos = [\"flex-start\", \"center\", \"flex-end\"];\r\n  if (typeof align === \"number\") align = pos[align + 1];\r\n  return align;\r\n}\r\nwindow.map_pos_x=map_pos_x\r\nfunction map_pos_y(align){\r\n  return map_pos_x(-align);\r\n}\r\nclass ZikoUIFlex extends ZikoUIElement {\r\n  constructor(tag =\"div\", w = \"50vw\", h = \"50vh\") {\r\n    super();\r\n    this.element = document.createElement(tag);\r\n    this.direction = \"cols\";\r\n    if (typeof w == \"number\") w += \"%\";\r\n    if (typeof h == \"number\") h += \"%\";\r\n    this.style({ border: \"1px solid black\", width: w, height: h });\r\n    this.style({ display: \"flex\" });\r\n    this.render();\r\n  }\r\n  resp(px,wrap = true) {\r\n    this.wrap(wrap);\r\n    if (this.element.clientWidth < px) this.vertical();\r\n    else this.horizontal();\r\n    return this;\r\n  }\r\n  setSpaceAround() {\r\n    this.style({ justifyContent: \"space-around\" });\r\n    return this;\r\n  }\r\n  setSpaceBetween() {\r\n    this.style({ justifyContent: \"space-between\" });\r\n    return this;\r\n  }\r\n  setBaseline() {\r\n    this.style({ alignItems: \"baseline\" });\r\n    return this;\r\n  }\r\n  gap(g) {\r\n    if (this.direction === \"row\") this.style({ columnGap: g });\r\n    else if (this.direction === \"column\") this.style({ rowGap: g });\r\n    return this;\r\n  }\r\n  wrap(value = \"wrap\") {\r\n    const values = [\"no-wrap\", \"wrap\",\"wrap-reverse\"];\r\n    this.style({\r\n      flexWrap: typeof value === \"string\" ? value : values[+value],\r\n    });\r\n    return this;\r\n  }\r\n  _justifyContent(align = \"center\") {\r\n    this.style({ justifyContent: align });\r\n    return this;\r\n  }\r\n  vertical(x, y, order=1) {\r\n    console.log(111111111111)\r\n    set_vertical.call(this,order)\r\n    this.style({\r\n      alignItems: typeof(x)===\"number\"?map_pos_x.call(this,x):x,\r\n      justifyContent: typeof(y)==\"number\"?map_pos_y.call(this,y):y\r\n    });\r\n    return this;\r\n  }\r\n  horizontal(x, y, order=1) {\r\n    set_horizontal.call(this,order)\r\n    this.style({\r\n      alignItems: typeof(y)==\"number\"?map_pos_y.call(this,y):y,\r\n      justifyContent: typeof(x)===\"number\"?map_pos_x.call(this,x):x\r\n    });\r\n    return this;\r\n  }\r\n  show() {\r\n    this.isHidden = false;\r\n    this.style({ display: \"flex\" });\r\n    return this;\r\n  }\r\n}\r\n\r\nconst Flex = (...ZikoUIElement) => new ZikoUIFlex(\"div\").append(...ZikoUIElement);\r\nconst FlexHeader = (...ZikoUIElement) => new ZikoUIFlex(\"header\").append(...ZikoUIElement);\r\nconst FlexMain = (...ZikoUIElement) => new ZikoUIFlex(\"main\").append(...ZikoUIElement);\r\nconst FlexArticle = (...ZikoUIElement) => new ZikoUIFlex(\"article\").append(...ZikoUIElement);\r\nconst FlexSection = (...ZikoUIElement) => new ZikoUIFlex(\"section\").append(...ZikoUIElement);\r\nconst FlexAside = (...ZikoUIElement) => new ZikoUIFlex(\"aside\").append(...ZikoUIElement);\r\nconst FlexNav = (...ZikoUIElement) => new ZikoUIFlex(\"nav\").append(...ZikoUIElement);\r\nconst FlexFooter = (...ZikoUIElement) => new ZikoUIFlex(\"footer\").append(...ZikoUIElement);\r\n\r\nexport{Flex,ZikoUIFlex,FlexHeader,FlexMain,FlexArticle,FlexSection,FlexAside,FlexFooter}",
  "UI_Flex_flex_js_stats_length": 3463,
  "UI_Flex_flex_js_stats_size": 3.3818359375,
  "UI_Flex_flex_js_stats_lines": 102,
  "UI_Flex_flex_js_metadata_permissions": 33206,
  "UI_Flex_index_js_content": "\r\n",
  "UI_Flex_index_js_stats_length": 2,
  "UI_Flex_index_js_stats_size": 0.001953125,
  "UI_Flex_index_js_stats_lines": 2,
  "UI_Flex_index_js_metadata_permissions": 33206,
  "UI_Grid_index_js_content": "\r\n",
  "UI_Grid_index_js_stats_length": 2,
  "UI_Grid_index_js_stats_size": 0.001953125,
  "UI_Grid_index_js_stats_lines": 2,
  "UI_Grid_index_js_metadata_permissions": 33206,
  "UI_List_elements_js_content": "",
  "UI_List_elements_js_stats_length": 0,
  "UI_List_elements_js_stats_size": 0,
  "UI_List_elements_js_stats_lines": 1,
  "UI_List_elements_js_metadata_permissions": 33206,
  "UI_List_index_js_content": "\r\n",
  "UI_List_index_js_stats_length": 2,
  "UI_List_index_js_stats_size": 0.001953125,
  "UI_List_index_js_stats_lines": 2,
  "UI_List_index_js_metadata_permissions": 33206,
  "UI_Media_index_js_content": "\r\n",
  "UI_Media_index_js_stats_length": 2,
  "UI_Media_index_js_stats_size": 0.001953125,
  "UI_Media_index_js_stats_lines": 2,
  "UI_Media_index_js_metadata_permissions": 33206,
  "UI_Semantic_index_js_content": "\r\n",
  "UI_Semantic_index_js_stats_length": 2,
  "UI_Semantic_index_js_stats_size": 0.001953125,
  "UI_Semantic_index_js_stats_lines": 2,
  "UI_Semantic_index_js_metadata_permissions": 33206,
  "UI_Style_index_js_content": "import { style , addSuffixeToNumber } from \"../Utils.js\";\r\n//import { addSuffixeToNumber } from \"../Utils.js\";\r\nexport function styleComposer(){\r\n    return {\r\n      style:function(styles,{target = \"parent\", maskVector = null } = {}){\r\n        if (target === \"parent\" || target === 0) {\r\n            style(this.element, styles);\r\n            Object.assign(this.cache.style,styles);\r\n        }\r\n        else if(target === \"parent\" || target === 0){\r\n          if (maskVector) {\r\n            this.items.map((n, i) => maskVector[i] == 1 && n.style(styles));\r\n          } \r\n          else this.items.map((n) => n.style(styles));      \r\n        }\r\n        return this;\r\n      },\r\n      // Css\r\n      setCss:function(css) {\r\n        this.element.style.cssText = css;\r\n        return this;\r\n      },\r\n      addCss:function(css) {\r\n        this.element.style.cssText += css;\r\n        return this;\r\n      },\r\n      // Dimensions\r\n      width:function(w,{ target, maskVector } = {}){\r\n        if(w instanceof Object){\r\n          if(w instanceof Array)w={min:w[0],max:w[1]}\r\n          if(\"min\" in w || \"max\" in w){\r\n            let min= w.min ?? w.max;\r\n            let max= w.max ?? w.min;\r\n            min=addSuffixeToNumber(min,\"px\");\r\n            max=addSuffixeToNumber(max,\"px\"); \r\n            this.style({ minWidth: min, maxWidth: max }, { target, maskVector });\r\n          }\r\n        }\r\n        else {\r\n          w=addSuffixeToNumber(w,\"px\");\r\n          this.style({width:w},{ target, maskVector });\r\n        }\r\n        return this\r\n      },\r\n      height:function(h,{ target, maskVector } = {}){\r\n        if(h instanceof Object){\r\n          if(h instanceof Array)h={min:h[0],max:h[1]}\r\n          if(\"min\" in h || \"max\" in h){\r\n            let min= h.min ?? h.max;\r\n            let max= h.max ?? h.min;\r\n            min=addSuffixeToNumber(min,\"px\");\r\n            max=addSuffixeToNumber(max,\"px\"); \r\n            this.style({ minHeight: min, maxHeight: max }, { target, maskVector });\r\n          }\r\n        }\r\n        else {\r\n          h=addSuffixeToNumber(h,\"px\");\r\n          this.style({height:h},{ target, maskVector });\r\n        }\r\n        return this\r\n      },\r\n      size:function(w,h,{ target, maskVector } = {}){\r\n        this.width(w,{ target, maskVector });\r\n        this.height(h,{ target, maskVector });\r\n        return this;\r\n      },\r\n      // Box Model \r\n      border:function(border = \"1px solid red\", { target, maskVector } = {}){\r\n        this.style({border}, { target, maskVector });\r\n        return this;\r\n      },\r\n      borderRadius:function(radius,{ target, maskVector } = {}){\r\n        radius=addSuffixeToNumber(radius,\"px\");\r\n        this.style({ borderRadius: radius }, { target, maskVector });\r\n        return this;\r\n      },\r\n      margin:function(margin,{ target, maskVector } = {}){\r\n        margin=addSuffixeToNumber(margin,\"px\");\r\n        this.style({ margin }, { target, maskVector });\r\n        return this;\r\n      },\r\n      padding:function(padding,{ target, maskVector } = {}){\r\n        padding=addSuffixeToNumber(padding,\"px\");\r\n        this.style({padding},{ target, maskVector });\r\n        return this;\r\n      },\r\n      // Placement \r\n      position:function(position,{ target, maskVector } = {}){\r\n        this.style({position},{ target, maskVector });\r\n        return this\r\n      },\r\n      display:function(disp, { target, maskVector } = {}) {\r\n        this.style({ display: disp }, { target, maskVector });\r\n        return this;\r\n      },\r\n      zIndex:function(z,{ target, maskVector } = {}){\r\n        this.style({zIndex:z},{ target, maskVector });\r\n        return this;\r\n      },\r\n      float:function(float, { target, maskVector } = {}) {\r\n        this.style({ float: float }, { target, maskVector });\r\n        return this;\r\n      },\r\n      // Apparences \r\n      color:function(color,{ target, maskVector } = {}){\r\n        this.style({color},{ target, maskVector });\r\n        return this;\r\n      },\r\n      background:function(background,{ target, maskVector } = {}){\r\n        this.style({background},{ target, maskVector });\r\n        return this;\r\n      },\r\n      opacity:function(opacity, { target, maskVector } = {}) {\r\n        this.style({ opacity }, { target, maskVector });\r\n        return this;\r\n      },\r\n      \r\n      \r\n      hide:function({after, target, maskVector } = {}){\r\n        if(typeof after===\"number\")setTimeout(() => this.hide({target,maskVector}), after);\r\n        else {\r\n          this.cache.isHidden=true;\r\n          this.style({display:\"none\"},{target,maskVector});\r\n        }\r\n        return this;\r\n      },\r\n      show:function({after, target, maskVector } = {}){\r\n        if(typeof after===\"number\")setTimeout(() => this.show({target,maskVector}), after);\r\n        else {\r\n          this.cache.isHidden=false;\r\n          this.style({display:\"\"},{target,maskVector});\r\n        }\r\n        return this;\r\n      },\r\n      \r\n      cursor:function(type=\"pointer\"){\r\n        this.style({ cursor: type });\r\n        return this;\r\n      },\r\n      overflow:function(x,y,{ target, maskVector } = {}){\r\n        const values=[\"hidden\",\"auto\"];\r\n        this.style({\r\n          overflowX:typeof x===\"number\"?values[x]:x,\r\n          overflowY:typeof y===\"number\"?values[y]:y\r\n        },{target,maskVector})\r\n        return this;\r\n      },\r\n      clip:function(polygon, { target, maskVector } = {}) {\r\n        if (typeof polygon === \"string\") polygon = \"polygon(\" + polygon + \")\";\r\n        this.style({ clipPath: polygon }, { target, maskVector });\r\n        return this;\r\n      }\r\n      \r\n    }\r\n  }\r\n\r\n\r\nexport default styleComposer;",
  "UI_Style_index_js_stats_length": 5582,
  "UI_Style_index_js_stats_size": 5.451171875,
  "UI_Style_index_js_stats_lines": 158,
  "UI_Style_index_js_metadata_permissions": 33206,
  "UI_Table_elements_js_content": "",
  "UI_Table_elements_js_stats_length": 0,
  "UI_Table_elements_js_stats_size": 0,
  "UI_Table_elements_js_stats_lines": 1,
  "UI_Table_elements_js_metadata_permissions": 33206,
  "UI_Table_index_js_content": "\r\n",
  "UI_Table_index_js_stats_length": 2,
  "UI_Table_index_js_stats_size": 0.001953125,
  "UI_Table_index_js_stats_lines": 2,
  "UI_Table_index_js_metadata_permissions": 33206,
  "UI_Table_table_js_content": "",
  "UI_Table_table_js_stats_length": 0,
  "UI_Table_table_js_stats_size": 0,
  "UI_Table_table_js_stats_lines": 1,
  "UI_Table_table_js_metadata_permissions": 33206,
  "UI_Text_heading_js_content": "",
  "UI_Text_heading_js_stats_length": 0,
  "UI_Text_heading_js_stats_size": 0,
  "UI_Text_heading_js_stats_lines": 1,
  "UI_Text_heading_js_metadata_permissions": 33206,
  "UI_Text_index_js_content": "\r\n",
  "UI_Text_index_js_stats_length": 2,
  "UI_Text_index_js_stats_size": 0.001953125,
  "UI_Text_index_js_stats_lines": 2,
  "UI_Text_index_js_metadata_permissions": 33206,
  "UI_Text_p_js_content": "",
  "UI_Text_p_js_stats_length": 0,
  "UI_Text_p_js_stats_size": 0,
  "UI_Text_p_js_stats_lines": 1,
  "UI_Text_p_js_metadata_permissions": 33206,
  "UI_Text_text_js_content": "",
  "UI_Text_text_js_stats_length": 0,
  "UI_Text_text_js_stats_size": 0,
  "UI_Text_text_js_stats_lines": 1,
  "UI_Text_text_js_metadata_permissions": 33206,
  "UI_Utils_index_js_content": "import ZikoUIElement from \"../ZikoUIElement.js\";\r\nconst Id = (a) => document.getElementById(a);\r\nconst Class = (a) => [...document.getElementsByClassName(a)];\r\nconst $=(...selector)=>{\r\n  var ele=[]\r\n  for(let i=0;i<selector.length;i++){\r\n    if(typeof selector[i]==\"string\")ele.push(...document.querySelectorAll(selector[i]));\r\n    if(selector[i] instanceof ZikoUIElement)ele.push(selector[i].element)\r\n  }\r\n  return ele.length===1?ele[0]:ele;\r\n}\r\nconst addSuffixeToNumber=(value,suffixe=\"px\")=>{\r\n  if(typeof value === \"number\") value+=suffixe;\r\n  if(value instanceof Array)value=value.map(n=>typeof n===\"number\"?n+=suffixe:n).join(\" \");\r\n  return value;\r\n}\r\nconst style = (el, styles) => Object.assign(el.style, styles);\r\n\r\nfunction script(src) {\r\n  const Script = document.createElement(\"script\");\r\n  Script.setAttribute(\"src\", src);\r\n  document.head.appendChild(Script);\r\n}\r\nfunction linkStyle(href) {\r\n  const link = document.createElement(\"link\");\r\n  link.setAttribute(\"rel\", \"stylesheet\");\r\n  link.setAttribute(\"href\", href);\r\n  document.head.appendChild(link);\r\n}\r\nconst CloneElement = (UIElement) => {\r\n  var clone = new UIElement.__proto__.constructor()\r\n  //waitForUIElm(UIElement).then(e=>console.log(e)).then(()=>clone = new UIElement.__proto__.constructor())\r\n  //let a = new UIElement.__proto__.constructor()\r\n  return clone;\r\n};\r\nconst cloneUI=UIElement=>{\r\n  return Object.assign(Object.create(Object.getPrototypeOf(UIElement)),UIElement)\r\n}\r\nconst waitForUIElm=(UIElement)=>{\r\n  return new Promise(resolve => {\r\n      if (UIElement.element) {\r\n          return resolve(UIElement.element);\r\n      }\r\n\r\n      const observer = new MutationObserver(() => {\r\n          if (UIElement.element) {\r\n              resolve(UIElement.element);\r\n              observer.disconnect();\r\n          }\r\n      });\r\n\r\n      observer.observe(document.body, {\r\n          childList: true,\r\n          subtree: true\r\n      });\r\n  });\r\n}\r\nvar waitForUIElmSync=(UIElement,timeout=2000)=>{\r\n  const t0=Date.now();\r\n  while(Date.now()-t0<timeout){\r\n    if(UIElement.element)return UIElement.element\r\n  }\r\n}\r\nfunction isPrimitive(value) {\r\n    return typeof value !== 'object' && typeof value !== 'function' || value === null;\r\n  }\r\n\r\nexport{Id,Class,style,script,linkStyle,CloneElement,cloneUI,waitForUIElm,waitForUIElmSync,isPrimitive,addSuffixeToNumber}",
  "UI_Utils_index_js_stats_length": 2344,
  "UI_Utils_index_js_stats_size": 2.2890625,
  "UI_Utils_index_js_stats_lines": 68,
  "UI_Utils_index_js_metadata_permissions": 33206,
  "UI_index_js_content": "\r\n",
  "UI_index_js_stats_length": 2,
  "UI_index_js_stats_size": 0.001953125,
  "UI_index_js_stats_lines": 2,
  "UI_index_js_metadata_permissions": 33206,
  "UI_ZikoUIElement_js_content": "//import {waitForUIElm, waitForUIElmSync } from \"./Utils.js\";\r\n//import domComposer from \"./Composer/dom.js\"\r\n//import {styleComposer} from \"./Composer/style.js\"\r\nclass ZikoUIElement {\r\n    #Flip=[0,0,0];\r\n    constructor(element=document.body) {\r\n      this.Target = Ziko.Target || document.body;\r\n      if(typeof element===\"string\")element=document.createElement(element);\r\n      this.element = element;\r\n      Object.assign(this,styleComposer.call(this));\r\n      Object.assign(this,domComposer.call(this));\r\n      this.cache={\r\n        isHidden:false,\r\n        style:{\r\n        },\r\n        attributes:{},\r\n        events:{},\r\n        filters:{\r\n          \r\n        }\r\n      }\r\n      this.items = [];\r\n      this.hooks={\r\n        states:{\r\n\r\n        }\r\n      }\r\n      this.style({ position: \"relative\" });\r\n      this.size(\"auto\", \"auto\");\r\n      //waitForUIElm(this).then(()=>Object.assign(this.cache.filters,{display:this.element.style.display}));\r\n      var ele=waitForUIElmSync(this,1000);\r\n      //console.log(ele)\r\n      //this.maintain()\r\n    } \r\n    /*size(w,h){\r\n        typeof w == \"number\" ? (this.w = w + \"vw\") : (this.w = w);\r\n        typeof h == \"number\" ? (this.h = h + \"vh\") : (this.h = h);\r\n        this.style({width:this.w,height:this.h});\r\n      }*/\r\n    clone() {\r\n      //const a = new ZikoUIElement(this.element.cloneNode(true));\r\n      //a.element.style=this.element.style\r\n      const clonedUI=new this.constructor()\r\n      a.render(true);\r\n      return clonedUI;\r\n    }\r\n   /* append(...ele) {\r\n      for (let i = 0; i < ele.length; i++)\r\n      if(ele[i] instanceof ZikoUIElement){\r\n        this.element.appendChild(ele[i].element);\r\n        ele[i].Target=this.element\r\n        this.items.push(ele[i]);\r\n      }   \r\n      else if(ele[i] instanceof Object){\r\n        if(ele[i]?.style)this.style(ele[i]?.style);\r\n        if(ele[i]?.attr){\r\n          Object.entries(ele[i].attr).forEach(n=>this.setAttribute(\"\"+n[0],n[1]))\r\n        }\r\n      }     \r\n      for(let i=0;i<this.items.length;i++)Object.assign(this,{[[i]]:this.items[i]})\r\n      return this;\r\n    }*/\r\n    // insertAt(index, ...ele) {\r\n    //   if (index >= this.element.children.length) this.append(...ele);\r\n    //   else\r\n    //     for (let i = 0; i < ele.length; i++)\r\n    //       this.element.insertBefore(ele[i].element, this.items[index].element);\r\n    //   return this;\r\n    // }\r\n    link(link, target = \"\") {\r\n      let a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", link);\r\n      if (target) a.setAttribute(\"target\", target);\r\n      this.element.addEventListener(\"click\", () => a.click());\r\n      this.element.style.cursor = \"pointer\";\r\n      return this;\r\n    }\r\n    // removeItem(...ele) {\r\n    //   const remove = (ele) => {\r\n    //     if (ele instanceof ZikoUIElement) this.element.removeChild(ele.element);\r\n    //     else if (typeof ele === \"number\")\r\n    //       this.element.removeChild(this.element.children[ele]);\r\n    //   };\r\n    //   for (let i = 0; i < ele.length; i++) remove(ele[i]);\r\n    //   return this;\r\n    // }\r\n    // setTarget(tg) {\r\n    //   if (tg instanceof ZikoUIElement) tg = tg.element;\r\n    //   this.remove();\r\n    //   this.Target = tg;\r\n    //   this.render();\r\n    //   return this;\r\n    // }\r\n    // render(bool = true) {\r\n    //   if (bool) this.Target.appendChild(this.element);\r\n    //   else this.remove();\r\n    //   return this;\r\n    // }\r\n    // remove() {\r\n    //   if (this.Target.children.length) this.Target.removeChild(this.element);\r\n    //   return this;\r\n    // }\r\n    // toggle() {\r\n    //   this.cache.isHidden ? this.show() : this.hide();\r\n    //   return this;\r\n    // }\r\n    // removeAfter(t = 1) {\r\n    //   setTimeout(() => this.remove(), t);\r\n    //   return this;\r\n    // }\r\n    get children() {\r\n      return [...this.element.children];\r\n    }\r\n    get cloneElement() {\r\n      return this.element.cloneNode(true);\r\n    }\r\n    toggle() {\r\n      this.cache.isHidden ? this.show() : this.hide();\r\n      return this;\r\n  }\r\n    /*\r\n    style(stl, { target = \"parent\", maskVector = null } = {}) {\r\n      if (target === \"parent\" || target === 0) {\r\n        style(this.element, stl);\r\n        Object.assign(this.cache.style,stl)\r\n      }\r\n      else if (target === \"children\" || target === 1) {\r\n        if (maskVector) {\r\n          this.items.map((n, i) => maskVector[i] == 1 && n.style(stl));\r\n        } else this.items.map((n) => n.style(stl));\r\n      }\r\n      return this;\r\n    }\r\n    */\r\n    get styleObject() {\r\n      //let borderPlus\r\n      return Object.fromEntries(\r\n        Object.entries(this.element.style).filter(\r\n          (n) => n[1] != \"\" && n[1] !== \"initial\" && isNaN(+n[0])\r\n        )\r\n      );\r\n    }\r\n    // setCss(css) {\r\n    //   this.element.style.cssText = css;\r\n    //   return this;\r\n    // }\r\n    // addCss(css) {\r\n    //   this.element.style.cssText += css;\r\n    //   return this;\r\n    // }\r\n    backgroundColor(background = \"#EEEEEE\", { target, maskVector } = {}) {\r\n      this.style({ backgroundColor: background }, { target, maskVector });\r\n      return this;\r\n    }\r\n    backgroundImage(\r\n      src,\r\n      { repeat = \"no-repeat\", blendMode = \"normal\", target, maskVector } = {}\r\n    ) {\r\n      if (src instanceof Array) src = src.map((n) => \"url(\" + n + \")\").join(\",\");\r\n      else src = \"url(\" + src + \")\";\r\n      //console.log(src)\r\n      this.style(\r\n        {\r\n          backgroundImage: src,\r\n          backgroundRepeat: repeat,\r\n          backgroundSize: \"cover\",\r\n          backgroundBlendMode: blendMode,\r\n        },\r\n        { target, maskVector }\r\n      );\r\n      return this;\r\n    }\r\n    backgroundGradient(colors, { target, maskVector, type = \"linear\" } = {}) {\r\n      if (colors instanceof Array) {\r\n        if (colors.length === 1) colors[1] = colors[0];\r\n        colors = colors.join(\",\");\r\n      }\r\n      this.style(\r\n        {\r\n          background: type + \"-gradient(\" + colors + \")\",\r\n        },\r\n        { target, maskVector }\r\n      );\r\n      return this;\r\n    }\r\n    colorGradient(colors, { target, maskVector, type = \"linear\" } = {}) {\r\n      if (colors instanceof Array) {\r\n        if (colors.length === 1) colors[1] = colors[0];\r\n        colors = colors.join(\",\");\r\n      }\r\n      var webkit = \"-webkit-\" + type + \"-gradient(\" + colors + \")\";\r\n      this.style(\r\n        {\r\n          background: webkit,\r\n          webkitBackgroundClip: \"text\",\r\n          webkitTextFillColor: \"transparent\",\r\n        },\r\n        { target, maskVector }\r\n      );\r\n      return this;\r\n    }\r\n    shadow(shadow = \"\", { target, maskVector } = {}) {\r\n      this.style({ textShadow: \"1px 1px 1px \" + shadow }, { target, maskVector });\r\n      return this;\r\n    }\r\n    boxShadow(shadow = \"\", { target, maskVector } = {}) {\r\n      this.style({ boxShadow: \"2px 2px 10px \" + shadow }, { target, maskVector });\r\n      return this;\r\n    }\r\n    /*\r\n    clip(polygon, { target, maskVector } = {}) {\r\n      if (typeof polygon === \"string\") polygon = \"polygon(\" + polygon + \")\";\r\n      this.style({ clipPath: polygon }, { target, maskVector });\r\n      return this;\r\n    }\r\n    \r\n    overflow(x, y, { target, maskVector } = {}) {\r\n      let value = Ziko.Math.Permutation.withDiscount([\"hidden\", \"auto\"]);\r\n      let index = Ziko.Math.bin2dec(+(x + \"\" + y));\r\n      //console.log(value,index)\r\n      let valueX = value[index][0];\r\n      let valueY = value[index][1];\r\n      this.style(\r\n        { overflowX: valueX, overflowY: valueY },\r\n        { target, maskVector }\r\n      );\r\n      return this;\r\n    }\r\n    */\r\n    /*display(disp, { target, maskVector } = {}) {\r\n      this.style({ display: disp }, { target, maskVector });\r\n      return this;\r\n    }*/\r\n    cssFilter(filter, { target, maskVector } = {}) {\r\n      this.style({ filter: filter }, { target, maskVector });\r\n      return this;\r\n    }\r\n    /*float(float, { target, maskVector } = {}) {\r\n      this.style({ float: float }, { target, maskVector });\r\n      return this;\r\n    }*/\r\n    font(f = \"italic bold 20px arial,serif\", { target, maskVector } = {}) {\r\n      this.style({ font: f }, { target, maskVector });\r\n      return this;\r\n    }\r\n    fontSize(size = \"20px\", { target, maskVector } = {}) {\r\n      this.style({ fontSize: size }, { target, maskVector });\r\n      return this;\r\n    }\r\n    fontFamily(n = \"Serif\", { target, maskVector } = {}) {\r\n      if (typeof n == \"number\") {\r\n        switch (n) {\r\n          case 0:\r\n            this.style({ fontFamily: \"Serif\" }, { target, maskVector });\r\n            break;\r\n          case 1:\r\n            this.style({ fontFamily: \"Sans-Serif\" }, { target, maskVector });\r\n            break;\r\n          case 2:\r\n            this.style({ fontFamily: \"Monospace\" }, { target, maskVector });\r\n            break;\r\n          case 3:\r\n            this.style({ fontFamily: \"Cursive\" }, { target, maskVector });\r\n            break;\r\n          case 4:\r\n            this.style({ fontFamily: \"Fantasy\" }, { target, maskVector });\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      } else this.style({ fontFamily: n }, { target, maskVector });\r\n      return this;\r\n    }\r\n    // contenteditable(bool = true) {\r\n    //   this.setAttribute(\"contenteditable\", bool);\r\n    //   return this;\r\n    // }\r\n    // setAttribute(name, value) {\r\n    //   this.element.setAttribute(name, value);\r\n    //   Object.assign(this.cache.attributes,Object.fromEntries([[name,value]]))\r\n    //   return this;\r\n    // }\r\n    // removeAttribute(name) {\r\n    //   this.element.setAttribute(name);\r\n    //   return this;\r\n    // }\r\n    setClass(value) {\r\n      this.setAttribute(\"class\", value);\r\n      return this;\r\n    }\r\n    get Classes() {\r\n      return this.element.getAttribute(\"class\");\r\n    }\r\n    addClass() {\r\n      /*this.setAttribute(\"class\", value);\r\n        return this;*/\r\n    }\r\n    setId(Id) {\r\n      this.element.setAttribute(\"id\", Id);\r\n      return this;\r\n    }\r\n    get Id() {\r\n      return this.element.getAttribute(\"id\");\r\n    }\r\n    filterByClass(value) {\r\n      let n = 0;\r\n      for (let i = 0; i < this.children.length; i++) {\r\n        for (let j = 0; j < this.children[i].classList.length; j++) {\r\n          if ([...this.children[i].classList][j] == value) n++;\r\n        }\r\n        if (n == 0) this.children[i].setAttribute(\"hidden\", true);\r\n        n = 0;\r\n      }\r\n    }\r\n    // filterByTextContent(value) {\r\n    //   let item = this.children;\r\n    //   let displays=this.items.map(n=>n.cache.filters.display)\r\n    //   item\r\n    //     .filter(n => !n.textContent.toLowerCase().includes((\"\"+value).toLowerCase()))\r\n    //     .map(n =>n.style.display = \"none\");\r\n    //   item\r\n    //     .filter(n => n.textContent.toLowerCase().includes((\"\"+value).toLowerCase()))\r\n    //     .map((n, i) => (n.style.display = displays[i]));\r\n    //   item.filter((n) => n.style.display != \"none\");\r\n    //   return this;\r\n    // }\r\n    sortByTextContent(value, displays) {\r\n      let item = this.children;\r\n      item\r\n        .filter((n) => !n.textContent.toLowerCase().includes(value.toLowerCase()))\r\n        .map((n) => {\r\n          n.style.display = \"none\";\r\n        });\r\n      item\r\n        .filter((n) => n.textContent.toLowerCase().includes(value.toLowerCase()))\r\n        .map((n, i) => (n.style.display = displays[i]));\r\n      //return item.filter(n=>n.style.display!=\"none\")\r\n      item.filter((n) => n.style.display != \"none\");\r\n      return this;\r\n    }\r\n    on(event, calback, { target = \"parent\", maskVector = null } = {}) {\r\n      if (target === \"parent\" || target === 0)\r\n        this.element.addEventListener(event, calback);\r\n      else if (target === \"children\" || target === 1) {\r\n        if (maskVector) {\r\n          this.items.map(\r\n            (n, i) =>\r\n              maskVector[i] == 1 && n.element.addEventListener(event, calback)\r\n          );\r\n        } else this.items.map((n) => n.element.addEventListener(event, calback));\r\n      }\r\n    }\r\n    onClick(calback, { target = \"parent\", maskVector = null } = {}) {\r\n      this.on(\"click\", calback, { target, maskVector });\r\n      return this;\r\n    }\r\n    onDbclick(calback, { target = \"parent\", maskVector = null } = {}) {\r\n      this.on(\"dbclick\", calback, { target, maskVector });\r\n      return this;\r\n    }\r\n    onMousedown(calback) {\r\n      this.element.addEventListener(\"mousedown\", calback);\r\n      return this;\r\n    }\r\n    onMousemove(calback) {\r\n      this.element.addEventListener(\"mousemove\", calback);\r\n      return this;\r\n    }\r\n    onMouseup(calback) {\r\n      this.element.addEventListener(\"mouseup\", calback);\r\n      return this;\r\n    }\r\n    onMouseenter(calback) {\r\n      this.element.addEventListener(\"mouseenter\", calback);\r\n      return this;\r\n    }\r\n    onMouseleave(calback) {\r\n      this.element.addEventListener(\"mouseleave\", calback);\r\n      return this;\r\n    }\r\n    onMouseout(calback) {\r\n      this.element.addEventListener(\"mouseout\", calback);\r\n      return this;\r\n    }\r\n    onMouseover(calback) {\r\n      this.element.addEventListener(\"mouseover\", calback);\r\n      return this;\r\n    }\r\n    onTouchmove(calback) {\r\n      this.element.addEventListener(\"touchmove\", calback);\r\n      return this;\r\n    }\r\n    onTouchup(calback) {\r\n      this.element.addEventListener(\"touchup\", calback);\r\n      return this;\r\n    }\r\n    onPointermove(calback) {\r\n      this.element.addEventListener(\"pointermove\", calback);\r\n      return this;\r\n    }\r\n    onPointerup(calback) {\r\n      this.element.addEventListener(\"pointerup\", calback);\r\n      return this;\r\n    }\r\n    onPointerdown(calback) {\r\n      this.element.addEventListener(\"pointerdown\", calback);\r\n      return this;\r\n    }\r\n    onPointerover(calback) {\r\n      this.element.addEventListener(\"pointerover\", calback);\r\n      return this;\r\n    }\r\n    onPointerleave(calback) {\r\n      this.element.addEventListener(\"pointerleave\", calback);\r\n      return this;\r\n    }\r\n    onPointerout(calback) {\r\n      this.element.addEventListener(\"pointerout\", calback);\r\n      return this;\r\n    }\r\n    onPointerenter(calback) {\r\n      this.element.addEventListener(\"pointerenter\", calback);\r\n      return this;\r\n    }\r\n  \r\n    onKeypress(calback) {\r\n      this.element.addEventListener(\"keypress\", calback);\r\n      return this;\r\n    }\r\n    onKeydown(calback) {\r\n      this.element.addEventListener(\"keydown\", calback);\r\n      return this;\r\n    }\r\n    onKeyup(calback) {\r\n      this.element.addEventListener(\"keyup\", calback);\r\n      return this;\r\n    }\r\n    get key() {\r\n      return event.key;\r\n    }\r\n    get keyCode() {\r\n      return event.keyCode;\r\n    }\r\n    get Event() {\r\n      return event;\r\n    }\r\n    handleSuccessifKeys(keys, calback) {\r\n      keys = keys.reverse();\r\n      const newkeys = new Array(keys.length).fill(null);\r\n      const addsub = (arr, item, length = keys.length) => {\r\n        arr.unshift(item);\r\n        arr.length = length;\r\n      };\r\n      this.keydown(() => {\r\n        addsub(newkeys, this.key);\r\n        if (newkeys.comp(keys)) {\r\n          this.preventDefault();\r\n          calback();\r\n          newkeys.fill(null);\r\n        }\r\n      });\r\n      return this;\r\n    }\r\n    preventDefault() {\r\n      return this.Event.preventDefault();\r\n    }\r\n    preventCopy() {\r\n      this.keydown(() => {\r\n        if (this.Event.ctrlKey && this.key == \"c\") this.preventDefault();\r\n      });\r\n    }\r\n    preventPaste() {\r\n      this.keydown(() => {\r\n        if (this.Event.ctrlKey && this.key == \"v\") this.preventDefault();\r\n      });\r\n    }\r\n    preventCut() {\r\n      this.keydown(() => {\r\n        if (this.Event.ctrlKey && this.key == \"x\") this.preventDefault();\r\n      });\r\n    }\r\n    preventSelect() {\r\n      this.onKeydown(() => {\r\n        if (this.Event.ctrlKey && this.key == \"a\") this.preventDefault();\r\n      });\r\n    }\r\n    draggable(bool = true) {\r\n      this.element.setAttribute(\"draggable\", bool);\r\n      return this;\r\n    }\r\n    get center() {\r\n      this.style({\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n      });\r\n      return this;\r\n    }\r\n    get Css_3d_obj() {\r\n      return null;\r\n      //return new THREE.CSS3DObject(this.element);\r\n    }\r\n    //VisibleArea\r\n    get Visible_area() {\r\n      //let bodyCoords=document.body.getBoundingClientRect();\r\n      let coords = this.element.getBoundingClientRect();\r\n      let windowHeight = document.documentElement.clientHeight;\r\n      let windowWidth = document.documentElement.clientWidth;\r\n      let topVisible = coords.top > 0 && coords.top < windowHeight;\r\n      let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;\r\n      let leftVisible = coords.left > 0 && coords.left < windowWidth;\r\n      let rightVisible = coords.right > 0 && coords.right < windowWidth;\r\n      //return topVisible || bottomVisible;\r\n      return {\r\n        top: topVisible,\r\n        bottom: bottomVisible,\r\n        left: leftVisible,\r\n        right: rightVisible,\r\n        heightRatio: (coords.height + coords.y) / coords.height,\r\n        isVisible: topVisible || bottomVisible || rightVisible || leftVisible,\r\n      };\r\n    }\r\n    \r\n    fadeOut(t = 1) {\r\n      this.style({ transition: t + \"s\", opacity: 0 });\r\n      return this;\r\n    }\r\n    fadeIn(t = 1) {\r\n      this.style({ transition: t + \"s\", opacity: 1 });\r\n      return this;\r\n    }\r\n    slideHeightIn(t = 1, h = this.h) {\r\n      this.style({ transition: t + \"s\", height: h });\r\n      return this;\r\n    }\r\n    slideHeightOut(t = 1) {\r\n      this.style({ transition: t + \"s\", height: 0 });\r\n      this.element.addEventListener(\"transitionend\", () =>\r\n        this.style({ opacity: \"none\" })\r\n      );\r\n      return this;\r\n    }\r\n    slideWidthIn(t = 1, w = this.w) {\r\n      this.style({ transition: t + \"s\", width: w });\r\n      return this;\r\n    }\r\n    slideWidthOut(t = 1) {\r\n      this.style({ transition: t + \"s\", width: 0 });\r\n      this.element.addEventListener(\"transitionend\", () =>\r\n        this.style({ opacity: \"none\" })\r\n      );\r\n      return this;\r\n    }\r\n    slideIn({ t = 1, w = \"100%\", h = \"auto\" } = {}) {\r\n      this.style({\r\n        transition: t + \"s\",\r\n        width: w,\r\n        height: h,\r\n        visibility: \"visible\",\r\n      });\r\n      return this;\r\n    }\r\n    slideOut({ t = 1, width = 0, height = 0 } = {}) {\r\n      this.style({\r\n        visibility: \"hidden\",\r\n        transition: t + \"s\",\r\n        opacity: \"none\",\r\n        width: width,\r\n        height: height,\r\n      });\r\n      this.element.addEventListener(\"transitionend\", () => {\r\n        this.style({ opacity: \"none\" });\r\n        console.log(1);\r\n      });\r\n      return this;\r\n    }\r\n    toggleSlide() {}\r\n    translateX(px, t = 0) {\r\n      this.style({ transform: \"translateX(\" + px + \"px)\" });\r\n      if (t != 0) this.style({ transition: \"all \" + t + \"s ease\" });\r\n      return this;\r\n    }\r\n    translateY(px, t = 0) {\r\n      this.style({ transform: \"translateY(\" + px + \"px)\" });\r\n      if (t != 0) this.style({ transition: \"all \" + t + \"s ease\" });\r\n      return this;\r\n    }\r\n    translate(x, y = x, t = 0) {\r\n      console.log(t);\r\n      this.style({ transform: \"translate(\" + x + \"px,\" + y + \"px)\" });\r\n      return this;\r\n    }\r\n    rotateX(deg, { duration = 0 } = {}) {\r\n      this.style({ transition: \"all \" + duration + \"s ease\" });\r\n      this.style({ transform: \"rotateX(\" + deg + \"deg)\" });\r\n      return this;\r\n    }\r\n    rotateY(deg, { duration = 0 } = {}) {\r\n      this.style({ transition: \"all \" + duration + \"s ease\" });\r\n      this.style({ transform: \"rotateY(\" + deg + \"deg)\" });\r\n      return this;\r\n    }\r\n    rotateZ(deg, { duration = 0 } = {}) {\r\n      this.style({ transition: \"all \" + duration + \"s ease\" });\r\n      this.style({ transform: \"rotateZ(\" + deg + \"deg)\" });\r\n      return this;\r\n    }\r\n    flipeX({ t = 1 } = {}) {\r\n      this.#Flip[0] += 180;\r\n      this.style({\r\n        transform: \"rotateX(\" + this.#Flip[0] + \"deg)\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    flipeY(t = 1) {\r\n      this.#Flip[1] += 180;\r\n      this.style({\r\n        transform: \"rotateY(\" + this.#Flip[1] + \"deg)\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    flipeZ(t = 1) {\r\n      this.#Flip[2] += 180;\r\n      this.style({\r\n        transform: \"rotateZ(\" + this.#Flip[2] + \"deg)\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    scaleX(sc, t = 1) {\r\n      this.style({\r\n        transform: \"scaleX(\" + sc + \")\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    scaleY(sc, t = 1) {\r\n      this.style({\r\n        transform: \"scaleY(\" + sc + \")\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    skewX(deg, t = 1) {\r\n      this.style({\r\n        transform: \"skewX(\" + deg + \"deg)\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    skewY(deg, t = 1) {\r\n      this.style({\r\n        transform: \"skewY(\" + deg + \"deg)\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    skew(x, y, t = 1) {\r\n      this.style({\r\n        transform: \"skew(\" + x + \"deg , \" + y + \"deg)\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    scale(x, y = x, t = 1) {\r\n      this.style({\r\n        transform: \"scale(\" + x + \",\" + y + \")\",\r\n        transition: \"all \" + t + \"s ease\",\r\n      });\r\n      return this;\r\n    }\r\n    resize(n = 0) {\r\n      switch (n) {\r\n        case 0:\r\n          this.style({ resize: \"none\" });\r\n          break;\r\n        case 1:\r\n          this.style({ resize: \"horizontal\" });\r\n          break;\r\n        case 2:\r\n          this.style({ resize: \"vertical\" });\r\n          break;\r\n        case 3:\r\n          this.style({ resize: \"both\" });\r\n          break;\r\n        default:\r\n          this.style({ resize: n });\r\n      }\r\n      return this;\r\n    }\r\n    Glassmorphism(background = \"rgba(255,255,255,0.1)\", blur = \"1px\") {\r\n      this.style({ background: background, backdropFilter: blur });\r\n      return this;\r\n    }\r\n    Neumorphism(r = \"50px\", bg = \"cyan\", box = \"13px -13px 49px #5d8fac\") {\r\n      this.style({ borderRadius: r, background: bg, boxShadow: box });\r\n      return this;\r\n    }\r\n    allowDrop(ev) {\r\n      ev.preventDefault();\r\n    }\r\n    drag(ev) {\r\n      ev.dataTransfer.setData(\"text\", ev.Target.id);\r\n    }\r\n    drop(ev) {\r\n      ev.preventDefault();\r\n      var data = ev.dataTransfer.getData(\"text\");\r\n      ev.Target.appendChild(document.getElementById(data));\r\n    }\r\n  \r\n    fullScreen(set = true, e) {\r\n      if (set) this.element.requestFullscreen(e);\r\n      else document.exitFullscreen();\r\n      return this;\r\n    }\r\n    toggleFullScreen(e) {\r\n      if (!document.fullscreenElement) this.element.requestFullscreen(e);\r\n      else document.exitFullscreen();\r\n      return this;\r\n    }\r\n    resizeObserver(calback) {\r\n      var observer = new ResizeObserver((element) => calback(element));\r\n      return observer.observe(this.element);\r\n    }\r\n    intersectionObserver(calback, target = \"parent\") {\r\n      if (target == \"parent\") {\r\n        var observer = new IntersectionObserver((element) => calback(element[0]));\r\n        return observer.observe(this.element);\r\n      }\r\n      return this.items.map((n) => n.intersectionObserver((e) => calback(e)));\r\n    }\r\n    intersectRatio(calback) {\r\n      var observer = new IntersectionObserver((element) =>\r\n        calback(element[0].intersectionRatio)\r\n      );\r\n      return observer.observe(this.element);\r\n    }\r\n    get coords(){\r\n      var rect=this.element.getBoundingClientRect()  \r\n      var parent={\r\n        cX:Math.floor(rect.left+(rect.right-rect.left)/2),\r\n        cY:Math.floor(rect.top+(rect.bottom-rect.top)/2 )\r\n      }\r\n      return {parent}\r\n    }\r\n    exportHTML() {}\r\n    toPdf() {\r\n      var newWindow = window.open();\r\n      var html = document.createElement(\"html\");\r\n      const head = document.head.cloneNode(true);\r\n      const body = document.createElement(\"body\");\r\n      const section = this.element.cloneNode(true);\r\n      console.log(section);\r\n      body.appendChild(section);\r\n      html.appendChild(head);\r\n      html.appendChild(body);\r\n      newWindow.document.write(html.innerHTML);\r\n      newWindow.document.close();\r\n      newWindow.print();\r\n      newWindow.close();\r\n      return this;\r\n    }\r\n  }\r\n  class ZikoUIRoot extends ZikoUIElement {\r\n    constructor() {\r\n      super();\r\n      this.element = document.body;\r\n      window.addEventListener(\"resize\", () => this.size());\r\n    }\r\n    size(w = window.innerWidth + \"px\", h = window.innerHeight + \"px\") {\r\n      this.element.style.width = w;\r\n      this.element.style.height = h;\r\n      return this;\r\n    }\r\n    append(element) {\r\n      this.element.appendChild(element.element);\r\n      return this;\r\n    }\r\n  }\r\n  const Root = (element) => new ZikoUIRoot().append(element);\r\n  window.ZikoUIElement=ZikoUIElement\r\n  export{Root,waitForUIElm}\r\n  export default ZikoUIElement",
  "UI_ZikoUIElement_js_stats_length": 24864,
  "UI_ZikoUIElement_js_stats_size": 24.28125,
  "UI_ZikoUIElement_js_stats_lines": 785,
  "UI_ZikoUIElement_js_metadata_permissions": 33206,
  "UI_ZikoUIRoot_js_content": "",
  "UI_ZikoUIRoot_js_stats_length": 0,
  "UI_ZikoUIRoot_js_stats_size": 0,
  "UI_ZikoUIRoot_js_stats_lines": 1,
  "UI_ZikoUIRoot_js_metadata_permissions": 33206,
  "Worker_index_js_content": "\r\n",
  "Worker_index_js_stats_length": 2,
  "Worker_index_js_stats_size": 0.001953125,
  "Worker_index_js_stats_lines": 2,
  "Worker_index_js_metadata_permissions": 33206,
  "index_js_content": "import {Math} from \"./Math/index.js\";\r\nconst Ziko={\r\n    Math\r\n}\r\nZiko.Math.ExtractAll=function(){\r\n    for (let i = 0; i < Object.keys(Ziko.Math).length; i++) {\r\n        globalThis[Object.keys(Ziko.Math)[i]] = Object.values(Ziko.Math)[i];\r\n    }\r\n    return this;\r\n}\r\nZiko.RemoveAll=function(){\r\n    for (let i = 0; i < Object.keys(Ziko.Math).length; i++) delete globalThis[Object.keys(Ziko.Math)[i]];   \r\n    return this;\r\n}\r\nexport default Ziko\r\n",
  "index_js_stats_length": 449,
  "index_js_stats_size": 0.4384765625,
  "index_js_stats_lines": 16,
  "index_js_metadata_permissions": 33206
}